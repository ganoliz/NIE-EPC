= Semestral work

== News

== Problem assignment

* *Implement class template `optional`*, which will represent a simplified analogy of the `std::optional` class template (*optionally conatainted value*).
* Class `optional` put into *the `epc` namespace*, such that its _fully-qualified name_ will be `::epc::optional`.
* Class `epc::optional<T>` will — similarly to `std::optional<T>` — implement *optionally contained/owned/managed value (object) of type `T`*.
** An object of type `epc::optional<T>` *may or may not contain/own* a value-object of type `T`.

[IMPORTANT]
====
* An object of type `epc::optional<T>` *is not allowed, in any case, to perform dynamic memory allocations*.
* _Consequence:_ the optionally contained value must be located directly  *inside the `optional` object*.
* Namely, the binary representation of contained-owned object *must be stored inside the binary representation of the owning `optional` object*.
====

* Conditions, under which `optional` object *does not contain value*:
** Initializatoin with the *default constructor*.
** *Initialization* by another `optional` object that *does not contain value* (with copy or move constructor).
** *Assignment* another `optional` objeckt that *does not contain value* (with copy or move assignment operator).
** *Swapping content* with another `optional` object that *does not contain value* (with member of free function `swap`).
** Calling member function `reset()`.
* For implementaion use language dialect (standard) *{cpp}11, {cpp}14, {cpp}17, or {cpp}20*.

[IMPORTANT]
====
- During implemnetation, pay attention to general principles of *correct and effective programmin*.
- Try to achive *maximum efficiency* from the perspective of utilization of computer resources, primarily *CPU time and system memory*.
- Write code in a *readable and understandable* way and *comment* it well if necessary.
====

== Solution and submission

- All your *implementation* — that is, the definition of the `epc::optional` class template, its member functions, and corresponding free functions — create in the form of a *single header file* named `optional.h`.
- Inidividual development versions *subsequently store* into the *branch called _semwork_* of your *repository of the NIE-EPC course on the faculty GitLab instance*.
- *Link to this repozitory* is https://gitlab.fit.cvut.cz/NI-EPC/B211/USERNAME, where *USERNAME* is you faculty username.
- Keep the implemented header file `optional.h` directly inside *the root directory of the _semwork_ branch*.
- *Deadline for submission* of the semestral work is the end of the last week of the semester teaching period, namely, *Sunday, December the 19th* (included).

WARNING: The *final submission* is considered the *version of the `optional.h` header file present in the repozitory at this deadline date*. *Any further updates might not be taken into consideration for the classification.*

[CAUTION]
====
* *Part of the final course exam* will be also the *discussion about the submitted solution*.
* Substantial *suspicion of non-individual development* of the submitted solution may result in *loss of points* for classification of semestral work.
====

[NOTE]
.Use of faculty GitLab
====
- To use the gitlab.fit.cvut.cz server, a *user account* needs to be available there. Such an account should be available automatically to each student, who is *present in the USERMAP database*.
- *Uploading and updating of files* are possible either via *web interface* or via an *arbitrary GIT client program*. In the second case, the user needs to upload into the account settings their *SSH public keys* and the *corresponding private key* needs to be used for the communication with the server.
- *Updates of the source code* via the web interface works such that you use the *“Edit” button* and rewrite the source code by its new version. Then, *describe the changes into the “Commit message” text field* and, finally, use the *“Commit changes” button*.
- An alternative for the “Edit” button is to use the *“Replace” button*, which allows to *replace the actual version of the file by the new one*, uploaded from the client computer system. Even in this case, *describe the corresponding file changes*.
====

[IMPORTANT]
====
- Individual commits should reflect *logical develpment parts* and should be *commented* accordingly in the *“Commit message”* text field.
- Examples of *suitable comments*: _“implementation of copy constructor”_, _“buffer misalignment corrected”_, _“initial emplace funciton implementation”_, etc.
- Examples of *unsuitable comments*: _“file update”_, _“implementation of other functions”_, _“new version”_, etc.
- Commit comments as well as comments in the code should be written in *English or Czech language*.
====

== Classificatoin

* For classification, *test programs* will be used, which verify correctness and functionality of submitted solution.
* In case that *it will not be possible to compile* the submitted solution (its compilation will result in an error), the classificatoin will be *base on the _“code review”_ (that is, based on its visual examination).
** In such a case, there is *no possiblity to define objective criteria for points assessment*, and this will be made *on a subjective basis without any point guarantees*.
* Otherwise, the point assessment will stem from the *success rate of the submitted solution with respect to the test programs set*.


== Application programming interface (API)

*Class template* `epc::optional`:

[source,c++]
----
// header file optional.h

namespace epc {

template <typename T>
class optional 
{
   ... // implementation to be made
};

... // free functions

} // namespace epc
----

=== Template parameters

* `T` — *value type*.

=== Public member types

* `value_type` — *value type* of the class (`T`).

=== Constructors and destructor

* `optional()` — *default constructor*. Constructs an object that *does not contain value*.

* `optional(const optional& other)` — *copy constructor*.
** If `other` *does contain value*, initializes value *by the expression `+*other+`*.
** If `other` *does not contain value*, constructs an object that *does not contain value* (similarly as default constructor).

* `optional(optional&& other)` — *move constructor*.
** If `other` *does contain value*, initializes value *by the expression `+std::move(*other)+`*.
** If `other` *does not contain value*, constructs an object that *does not contain value* (similarly as default constructor).

* `+template <typename... Ts> optional(std::in_place_t, Ts&&... args)+` — *converting constructor*.
** Initializes value by the *_perfect forwarding_ technique applied on arguments* `+args...+`.

* `~optional()` — *destructor*. 
** If the actual object (`+*this+`) does contain value, that is *destructed*.
** Otherwise, it does not perform any operation.

=== Assignment operators

* `optional& operator=(const optional& other)` — *copy assignment operator*.
** If the _source object_ (`other`) a the _destination object_ (`+*this+`) both do not contain value, it has *no effect*.
** If the _destination object_ does contain value and the _source object_ does not, the *value of the _destination object_ is destructed*.
** If the _destination object_ does not contain value and the _source object_ does, *initializes the value of the _destination object_* by the expression `+*other+`.
** If both the _source object_ and the _destination object_ do contain value, the *value of the _destination object_ is assigned to the value of the _source object_* by the epxression  `+= *other+`.
** Returns a reference to itself (_destination object_).

* `optional& operator=(optional&& other)` — *move assignment operator*.
** If the _source object_ (`other`) a the _destination object_ (`+*this+`) both do not contain value, it has *no effect*.
** If the _destination object_ does contain value and the _source object_ does not, the *value of the _destination object_ is destructed*.
** If the _destination object_ does not contain value and the _source object_ does, *initializes the value of the _destination object_* by the expression `+std::move(*other)+`.
** If both the _source object_ and the _destination object_ do contain value, the *value of the _destination object_ is assigned to the value of the _source object_* by the epxression  `+= std::move(*other)+`.
** Returns a reference to itself (_destination object_).

=== Other member functions

* `+const T* operator->() const+` — returns a *pointer to the contained value*. In case there is no value contained, yields *undefined behavior*.
* `+T* operator->()+` —  returns a *pointer to the contained value*. In case there is no value contained, yields *undefined behavior*.

* `+const T& operator*() const+` — returns a  *reference to the contained value*. In case there is no value contained, yields *undefined behavior*.
* `+T& operator*()+` — returns a  *reference to the contained value*. In case there is no value contained, yields *undefined behavior*.

* `operator bool() const` — returns *`true` nebo `false`* in case that the actual object (`+*this+`) *does or does not contain value*, respectively.

* `void swap(optional& other)` — *swap content* of the _destination object_ (`+*this+`) and the _source object_ (`other`).
** If the _source object_ and the _destination object_ both do not contain value, it has *no effect*.
** If the _destination object_ does contain value and the _source object_ does not, first, *initializes the value of the _source object* by the expression `+std::move(**this)+`, and then, *destructs* the value of the _destination object_.
** If the _destination object_ does not contain value and the _source object_ does, firts, *initializes the value of the _destination object* by the expression  `+std::move(*other)+`, and then, *destructs* the value of the _source object_.
** If both the _source object_ and the _destination object_ do contain value, *swaps their content* byt calling `+using std::swap; swap(**this, *other);+`.

* `void reset()`
** If the actual object (`+*this+`) does contain value, this is *destructed*.
** Otherwise, it has no effect.

* `+template <typename... Ts> void emplace(Ts...&& args)+`
** If the actual object (`+*this+`) does contain value, this is *destructed* first.
** The, it initializs the new value by the *_perfect forwarding_ technique applied to the arguments* `+args...+`.

=== Free functions

* `template <typename T> void swap(optional<T>& a, optional<T>& b)` — *swaps content* of the objects `a` a `b` (effectively equivalent with calling `a.swap(b)`).

WARNING: Free functions shall be in the same *namespace* `epc`.