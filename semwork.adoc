= Semestral work

== News

== Problem Assignment

* *Implement class template `optional`*, which will represent a simplified analogy of the `std::optional` class template (*optionally conatainted value*).
* Class `optional` put into *the `epc` namespace*, such that its _fully-qualified name_ will be `::epc::optional`.
* Class `epc::optional<T>` will — similarly to `std::optional<T>` — implement *optionally contained/owned/managed value (object) of type `T`*.
** An object of type `epc::optional<T>` *may or may not contain/own* a value-object of type `T`.

[IMPORTANT]
====
* An object of type `epc::optional<T>` *is not allowed, in any case, to perform dynamic memory allocations*.
* _Consequence:_ the optionally contained value must be located directly  *inside the `optional` object*.
* Namely, the binary representation of contained-owned object *must be stored inside the binary representation of the owning `optional` object*.
====

* Conditions, under which `optional` object *does not contain value*:
** Initializatoin with the *default constructor*.
** *Initialization* by another `optional` object that *does not contain value* (with copy or move constructor).
** *Assignment* another `optional` objeckt that *does not contain value* (with copy or move assignment operator).
** *Swapping content* with another `optional` object that *does not contain value* (with member of free function `swap`).
** Calling member function `reset()`.
* For implementaion use language dialect (standard) *{cpp}11, {cpp}14, {cpp}17, or {cpp}20*.

[IMPORTANT]
====
- Při implementaci dbejte obecných zásad pro *korektní a efektivní programování*. 
- Snažte se o *maximální možnou efektivitu* z hlediska využití prostředků počítače, především *času procesoru a operační paměti*.
- Dbejte na *čitelnost a přehlednost* zdrojového kódu, v případě potřeby kód příslušně *komentujte*.
====

== Vypracování a odevzdání

- Veškerou *implementaci* — tj. definici šablonové třídy `epc::optional`, její členské funkce, a příslušné volné funkce — realizujte formou *jediného hlavičkového souboru* s názvem `optional.h`.
- Vývojové verze *postupně ukládejte* do *větve s názvem _semwork_* vašeho *repozitáře předmětu NI-EPC na fakultní instanci Gitlab*.
- *Odkaz na tento repozitář* je https://gitlab.fit.cvut.cz/NI-EPC/B211/USERNAME, kde *USERNAME* je vaše fakultní uživatelské jméno.
- Vyvíjený hlavičkový soubor `optional.h` mějte přímo *v kořenovém adresáři větve _semwork_*.
- *Termín pro odevzdání* semestrální práce je konec posledního výukového týdnu v semestru, tj. *neděle 19. prosince* (včetně).

WARNING: Za **výsledné odevzdání** semestrální práce se považuje **verze souboru `optional.h` platná na konci tohoto termínu**. **Na pozdější úpravy nemusí být brán při hodnocení zřetel.**

[CAUTION]
====
* *Diskuze nad odevzdaným řešením* bude součástí *ústní zkoušky*.
* Závažné *podezření na nesamostatné vypracování* odevzdaného řešení může vést na *odebrání bodů* za hodnocení semestrální práce.*
====

[NOTE]
.Práce s fakultním GitLabem
====
- Pro práci se serverem gitlab.fit.cvut.cz je zapotřebí mít na tomto serveru založený *uživatelský účet*. Ten by měl mít automaticky každý student, který je *zaveden v USERMAPu*.
- *Nahrávání a aktualizace souborů* jsou možné buď *přes webové rozhraní*, nebo pomocí *libovolného GIT klientského programu*. V druhém případě je nutné nahrát do nastavení účtu *veřejný SSH klíč* a *příslušný soukromý klíč* použít v klientském softwaru pro komunikaci se serverem.
- Přes webové rozhraní probíhá *aktualizace zdrojového kódu* tak, že u souboru použijete *tlačítko „Edit“* a přepíšete zdrojový kód novou verzí. Poté *popíšete změnu do textového pole „Commit message“* a nakonec použijete *tlačítko „Commit changes“*.
- Alternativně k tlačítku „Edit“ je možné použít *tlačítko „Replace“*, které umožní *stávající verzi souboru nahradit novou*, nahranou z počítače. I v tomto případě *uveďte příslušný popis změn*.
====

[IMPORTANT]
====
- Jednotlivé „commity“ by měly odrážet *logické celky při vývoji* a měly by být podle toho *komentovány* v textovém poli *„Commit message“*.
- Příklady *vhodných komentářů*: _„implementace kopírovacího konstruktoru“_, _„odstranění chyby v nesprávném zarovnání“_, _„iniciální implementace funkce emplace“_, atd.
- Příklady *nevhodných komentářů*: _„aktualizace souboru“_, _„implementace dalších funkcí“_, _„nová verze“_, atd.
- Komentáře commitů stejně jako komentáře v kódu piště v *českém nebo anglickém jazyce*.
====

== Hodnocení

* K hodnocení budou využity *testovací programy*, které ověří korektnost a funkčnost odevzdaného řešení.
* Pokud odevzdaný kód *nepůjde přeložit* (tj. překlad skončí s chybou), bude hodnocení provedeno *na základě „_code review_“* (tj. na základě jeho vizuálního prozkoumání).
** V takovém případě *nelze definovat objektivní kritéria pro bodové hodnocení*, a to bude tudíž provedeno *subjektivně bez jakýchkoliv bodových záruk*.
* V opačném případě bude hodnocení vycházet z *úspěšnosti odevzdaného řešení v rámci testovacích programů*.

== Aplikační programové rozhraní (API)

*Šablonová třída* `epc::optional`:

[source,c++]
----
// header file optional.h

namespace epc {

template <typename T>
class optional 
{
   ... // implementation to be made
};

... // free functions

} // namespace epc
----

=== Šablonové parametry

* `T` — *hodnotový typ (_value type_)*.

=== Veřejné členské typy

* `value_type` — *hodnotový typ* (_value type_) třídy (`T`).

=== Konstruktory a destruktor

* `optional()` — *výchozí konstruktor*. Konstruuje objekt, který *neobsahuje hodnotu*.

* `optional(const optional& other)` — *kopírovací konstruktor*.
** Pokud `other` *obsahuje hodnotu*, inicializuje hodnotu *pomocí výrazu `+*other+`*.
** Pokud `other` *neobsahuje hodnotu*, konstruuje objekt, který *neobsahuje hodnotu* (podobně jako výchozí konstruktor).

* `optional(optional&& other)` — *přesouvací konstruktor*.
** Pokud `other` *obsahuje hodnotu*, inicializuje hodnotu *pomocí výrazu `+std::move(*other)+`*.
** Pokud `other` *neobsahuje hondnotu*, konstruuje objekt, který *neobsahuje hodnotu* (podobně jako výchozí konstruktor).

* `+template <typename... Ts> optional(std::in_place_t, Ts&&... args)+` — konverzní konstruktor.
** Inicializuje hodnotu pomocí techniky *_perfect forwarding_ aplikované na argumenty* `+args...+`.

* `~optional()` — *destruktor*. 
** Pokud aktuální objekt (`+*this+`) obsahuje hodnotu, tak ji *zdestruuje*.
** V opačném případě neprovádí žádnou operaci.

=== Přiřazovací operátory

* `optional& operator=(const optional& other)` — *kopírovací přiřazovací operátor*.
** Pokud _zdrojový objekt_ (`other`) a _cílový objekt_ (`+*this+`) oba neobsahují hodnotu, nemá *žádný efekt*.
** Pokud _cílový objekt_ obsahuje hodnotu a _zdrojový objekt_ ji neobsahuje, je *hodnota _cílového objektu_ zdestruována*.
** Pokud _cílový objekt_ neobsahuje hodnotu a _zdrojový objekt_ ji obsahuje, *inicializuje hodnotu _cílového objektu_* pomocí výrazu `+*other+`.
** Pokud _zdrojový objekt_ i _cílový objekt_ oba obsahují hodnotu, je *hodnota _cílového objektu_ přiřazena hodnotě _zdrojového objektu_* pomocí výrazu `+= *other+`.
** Vrací referenci na sebe sama (_cílový objekt_).

* `optional& operator=(optional&& other)` — *přesouvací přiřazovací operátor*.
** Pokud _zdrojový objekt_ (`other`) a _cílový objekt_ (`+*this+`) oba neobsahují hodnotu, nemá *žádný efekt*.
** Pokud _cílový objekt_ obsahuje hodnotu a _zdrojový objekt_ ji neobsahuje, je *hodnota _cílového objektu_ zdestruována*.
** Pokud _cílový objekt_ neobsahuje hodnotu a _zdrojový objekt_ ji obsahuje, *inicializuje hodnotu _cílového objektu_* pomocí výrazu `+std::move(*other)+`.
** Pokud _zdrojový objekt_ i _cílový objekt_ oba obsahují hodnotu, je *hodnota _cílového objektu_ přiřazena hodnotě _zdrojového objektu_* pomocí výrazu `+= std::move(*other)+`.
** Vrací referenci na sebe sama (_cílový objekt_).

=== Ostatní členské funkce

* `+const T* operator->() const+` — vrací *ukazatel na obsaženou hodnotu*. V případě, že obsažená není, vede na *nedefinované chování*.
* `+T* operator->()+` — vrací *ukazatel na obsaženou hodnotu*. V případě, že obsažená není, vede na *nedefinované chování*.

* `+const T& operator*() const+` — vrací *referenci na obsaženou hodnotu*. V případě, že obsažená není, vede na *nedefinované chování*.
* `+T& operator*()+` — vrací *referenci na obsaženou hodnotu*. V případě, že obsažená není, vede na *nedefinované chování*.

* `operator bool() const` — vrací *`true` nebo `false`* v případě, že aktuální objekt (`+*this+`) *obsahuje nebo neobsahuje hodnotu*, v uvedeném pořadí.

* `void swap(optional& other)` — *prohození obsahu* _cílového objektu_ (`+*this+`) a _zdrojového objektu_ (`other`).
** Pokud _zdrojový objekt_ a _cílový objekt_ oba neobsahují hodnotu, nemá *žádný efekt*.
** Pokud _cílový objekt_ obsahuje hodnotu a _zdrojový objekt_ ji neobsahuje, nejprve *inicializuje hodnotu _zdrojového objektu_* pomocí výrazu `+std::move(**this)+` a poté *zdestruuje* hodnotu _cílového objektu_.
** Pokud _cílový objekt_ neobsahuje hodnotu a _zdrojový objekt_ ji obsahuje, nejprve *inicializuje hodnotu _cílového objektu_* pomocí výrazu `+std::move(*other)+` a poté *zdestruuje* hodnotu _zdrojového objektu_.
** Pokud _zdrojový objekt_ i _cílový objekt_ oba objekty obsahují hodnotu, *prohodí jejich obsah* voláním `+using std::swap; swap(**this, *other);+`.

* `void reset()`
** Pokud aktuální objekt (`+*this+`) obsahuje hodnotu, tak ji *zdestruuje*.
** Jinak nemá žádný efekt.

* `+template <typename... Ts> void emplace(Ts...&& args)+`
** Pokud aktuální objekt (`+*this+`) obsahuje hodnotu, tak ji nejprve *zdestruuje*.
** Poté inicializuje novou hodnotu pomocí techinky *_perfect forwarding_ aplikované na argumenty* `+args...+`.

=== Volné funkce

* `template <typename T> void swap(optional<T>& a, optional<T>& b)` — *prohození obsahu* objektů `a` a `b` (efektivně ekvivalentní s voláním `a.swap(b)`).

WARNING: Volné funkce se musí nacházet rovněž ve *jmenném prostoru* `epc`.