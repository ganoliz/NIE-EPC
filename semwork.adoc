= Semester project

== News

* [15.11.2021] Link to the test program #5: https://godbolt.org/z/4f6GPYhvM. Testing *copy assignment operator*.
* [8.11.2021] Link to the test program #4: https://godbolt.org/z/9589q7nrx. Testing *copy and move constructor* by means of a value type *with copy and move semantics*.
* [8.11.2021] Link to the test program #3: https://godbolt.org/z/h77qnd1n7. Testing *copy and move constructor* by means of a value type *without move semantics*.
* [26.10.2021] Link to the test program #2: https://godbolt.org/z/z6xY6YbKT. Testing creation (initialization) of a value *by the correct constructor*.
* [26.10.2021] Link to the test program #1: https://godbolt.org/z/9seo4x1Ks. Testing of the *default constructor* (must not create a value) and *storage of a value* created through the converting constructor in the *included storage*.

[IMPORTANT]
====
* The test programs work with the `ns::optional` template, where the namespace alias `ns` is *by default set to `std`*.
* To use own solution, *this alias needs to be reset to the `epc` namespace*.
* For testing purposes, it is possible either to *download the test program* (copy its source code), or *copy own solution into the `optional.h` header file*.
====

* [26.10.2021] *Corrected typo* in the interface of the `emplace` member function.

== Problem assignment

* *Implement class template `optional`*, which will represent a simplified analogy of the `std::optional` class template (*optionally containted value*).
* Put class `optional` into *the `epc` namespace*, such that its _fully-qualified name_ will be `::epc::optional`.
* Class `epc::optional<T>` will — similarly to `std::optional<T>` — implement *optionally contained/owned/managed value (object) of type `T`*.
** An object of type `epc::optional<T>` *may or may not contain/own* a value-object of type `T`.

[IMPORTANT]
====
* An object of type `epc::optional<T>` *is not allowed, in any case, to perform dynamic memory allocations*.
* _Consequence:_ the optionally contained value must be located directly  *inside the `optional` object*.
* Namely, the binary representation of contained-owned object *must be stored inside the binary representation of the owning `optional` object*.
====

* Conditions, under which `optional` object *does not contain value*:
** Initialization with the *default constructor*.
** *Initialization* by another `optional` object that *does not contain value* (with copy or move constructor).
** *Assignment* another `optional` object that *does not contain value* (with copy or move assignment operator).
** *Swapping content* with another `optional` object that *does not contain value* (with member of free function `swap`).
** Calling member function `reset()`.
* For implementation use only “pure” {cpp}, namely its standard *{cpp}11 or {cpp}14*.

[IMPORTANT]
====
- During implementation, pay attention to general principles of *correct and effective programming*.
- Try to achieve *maximum efficiency* from the perspective of utilization of computer resources, primarily *CPU time and system memory*.
- Write code in a *readable and understandable* way and *comment* it well if necessary.
====

== Solution and submission

- All your *implementation* — that is, the definition of the `epc::optional` class template, its member functions, and corresponding free functions — create in the form of a *single header file* named `optional.h`.
- Individual development versions *subsequently store* into the *branch called _semwork_* of your *repository of the NIE-EPC course on the faculty GitLab instance*.
- *Link to this repository* is https://gitlab.fit.cvut.cz/NI-EPC/B211/USERNAME, where *USERNAME* is your faculty username.
- Keep the implemented header file `optional.h` directly inside *the root directory of the _semwork_ branch*.
- *Deadline for submission* of the semestral work is the end of the last week of the semester teaching period, namely, *Sunday, December the 19th* (included).

WARNING: The *final submission* is considered to be the *version of the `optional.h` header file present in the repository at this deadline date*. *Any further updates might not be taken into consideration for the classification.*

[CAUTION]
====
* *A part of the final course exam* will be also the *discussion about the submitted solution*.
* Substantial *suspicion of non-individual development* of the submitted solution may result in *loss of points* for classification of semestral work.
====

[NOTE]
.Use of faculty GitLab
====
- A *user account* is required to use the gitlab.fit.cvut.cz server. Such an account should be available automatically for each student *present in the USERMAP database*.
- *Uploading and updating files* is possible either via *web interface* or via an *arbitrary GIT client program*. In the second case, a user needs to upload — into their account settings — an *SSH public keys* and the *corresponding private key* needs to be used for the communication with the server.
- *Updates of the source code* via the web interface works such that you use the *“Edit” button* and rewrite the source code by its new version. Then, *describe the changes into the “Commit message” text field* and, finally, hit the *“Commit changes” button*.
- An alternative for the “Edit” button is to use the *“Replace” button*, which allows to *replace the actual version of the file by the a one*, uploaded from the client computer system. Even in this case, *describe the corresponding file changes*.
====

[IMPORTANT]
====
- Individual commits should reflect *logical development parts* and should be *commented* accordingly in the *“Commit message”* text field.
- Examples of *suitable comments*: _“implementation of copy constructor”_, _“buffer misalignment corrected”_, _“initial emplace function implementation”_, etc.
- Examples of *unsuitable comments*: _“file update”_, _“implementation of other functions”_, _“new version”_, etc.
- Commit comments as well as comments in the code should be written in *English or Czech language*.
====

== Classification

* For classification, *test programs* will be used, which will verify correctness and functionality of the submitted solution.
* In case that *it will not be possible to compile* the submitted solution (its compilation will result in errors), the classification will be *based on _“code review”_ (that is, based on code visual examination).
** In such a case, there is *no possibility to define objective criteria for points assessment*, and this will be made *on subjective basis without any point guarantees*.
* Otherwise, the point assessment will stem from the *success rate of the submitted solution with respect to the test programs set*.

== Application programming interface (API)

*Class template* `epc::optional`:

[source,c++]
----
// header file optional.h

namespace epc {

template <typename T>
class optional 
{
   ... // implementation to be made
};

... // free functions

} // namespace epc
----

=== Template parameters

* `T` — *value type*.

=== Public member types

* `value_type` — *value type* of the class (`T`).

=== Constructors and destructor

* `optional()` — *default constructor*. Constructs an object that *does not contain value*.

* `optional(const optional& other)` — *copy constructor*.
** If `other` *does contain value*, initializes value *by the expression `+*other+`*.
** If `other` *does not contain value*, constructs an object that *does not contain value* (similarly as default constructor).

* `optional(optional&& other)` — *move constructor*.
** If `other` *does contain value*, initializes value *by the expression `+std::move(*other)+`*.
** If `other` *does not contain value*, constructs an object that *does not contain value* (similarly as default constructor).

* `+template <typename... Ts> optional(epc::in_place_t, Ts&&... args)+` — *converting constructor*.
** Initializes value by the *_perfect forwarding_ technique applied on arguments* `+args...+`.
** `in_place_t` “tag-dispatching” type will be defined in the `epc` namespace as follows:

[source,c++]
----
// within namespace epc:
struct in_place_t {
  explicit in_place_t() = default;
};
----

* `~optional()` — *destructor*. 
** If the actual object (`+*this+`) does contain value, that is *destructed*.
** Otherwise, it does not perform any operation.

=== Assignment operators

* `optional& operator=(const optional& other)` — *copy assignment operator*.
** If the _source object_ (`other`) and the _destination object_ (`+*this+`) both do not contain value, it has *no effect*.
** If the _destination object_ does contain value and the _source object_ does not, the *value of the _destination object_ is destructed*.
** If the _destination object_ does not contain value and the _source object_ does, *initializes the value of the _destination object_* by the expression `+*other+`.
** If both the _source object_ and the _destination object_ do contain value, the *value of the _destination object_ is assigned to the value of the _source object_* by the expression  `+= *other+`.
** Returns a reference to itself (_destination object_).

* `optional& operator=(optional&& other)` — *move assignment operator*.
** If the _source object_ (`other`) and the _destination object_ (`+*this+`) both do not contain value, it has *no effect*.
** If the _destination object_ does contain value and the _source object_ does not, the *value of the _destination object_ is destructed*.
** If the _destination object_ does not contain value and the _source object_ does, *initializes the value of the _destination object_* by the expression `+std::move(*other)+`.
** If both the _source object_ and the _destination object_ do contain value, the *value of the _destination object_ is assigned to the value of the _source object_* by the expression  `+= std::move(*other)+`.
** Returns a reference to itself (_destination object_).

=== Other member functions

* `+const T* operator->() const+` — returns a *pointer to the contained value*. In case there is no value contained, yields *undefined behavior*.
* `+T* operator->()+` —  returns a *pointer to the contained value*. In case there is no value contained, yields *undefined behavior*.

* `+const T& operator*() const+` — returns a  *reference to the contained value*. In case there is no value contained, yields *undefined behavior*.
* `+T& operator*()+` — returns a  *reference to the contained value*. In case there is no value contained, yields *undefined behavior*.

* `operator bool() const` — returns *`true` or `false`* in case that the actual object (`+*this+`) *does or does not contain value*, respectively.

* `void swap(optional& other)` — *swap content* of the _destination object_ (`+*this+`) and the _source object_ (`other`).
** If the _source object_ and the _destination object_ both do not contain value, it has *no effect*.
** If the _destination object_ does contain value and the _source object_ does not, first, *initializes the value of the _source object_* by the expression `+std::move(**this)+`, and then, *destructs* the value of the _destination object_.
** If the _destination object_ does not contain value and the _source object_ does, first, *initializes the value of the _destination object_* by the expression  `+std::move(*other)+`, and then, *destructs* the value of the _source object_.
** If both the _source object_ and the _destination object_ do contain value, *swaps their content* by calling `+using std::swap; swap(**this, *other);+`.

* `void reset()`
** If the actual object (`+*this+`) does contain value, this is *destructed*.
** Otherwise, it has no effect.

* [.line-through]#`+template <typename... Ts> void emplace(Ts...&& args)+`#
* `+template <typename... Ts> void emplace(Ts&&... args)+`
** If the actual object (`+*this+`) does contain value, this is *destructed* first.
** Then, it initializes the new value by the *_perfect forwarding_ technique applied to the arguments* `+args...+`.

=== Free functions

* `template <typename T> void swap(optional<T>& a, optional<T>& b)` — *swaps content* of the objects `a` a `b` (effectively equivalent with calling `a.swap(b)`).

WARNING: Free functions shall be in the same *namespace* `epc`.