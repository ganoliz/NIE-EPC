= Semestral work

== News

== Problem assignment

* *Implement class template `optional`*, which will represent a simplified analogy of the `std::optional` class template (*optionally conatainted value*).
* Class `optional` put into *the `epc` namespace*, such that its _fully-qualified name_ will be `::epc::optional`.
* Class `epc::optional<T>` will — similarly to `std::optional<T>` — implement *optionally contained/owned/managed value (object) of type `T`*.
** An object of type `epc::optional<T>` *may or may not contain/own* a value-object of type `T`.

[IMPORTANT]
====
* An object of type `epc::optional<T>` *is not allowed, in any case, to perform dynamic memory allocations*.
* _Consequence:_ the optionally contained value must be located directly  *inside the `optional` object*.
* Namely, the binary representation of contained-owned object *must be stored inside the binary representation of the owning `optional` object*.
====

* Conditions, under which `optional` object *does not contain value*:
** Initializatoin with the *default constructor*.
** *Initialization* by another `optional` object that *does not contain value* (with copy or move constructor).
** *Assignment* another `optional` objeckt that *does not contain value* (with copy or move assignment operator).
** *Swapping content* with another `optional` object that *does not contain value* (with member of free function `swap`).
** Calling member function `reset()`.
* For implementaion use language dialect (standard) *{cpp}11, {cpp}14, {cpp}17, or {cpp}20*.

[IMPORTANT]
====
- During implemnetation, pay attention to general principles of *correct and effective programmin*.
- Try to achive *maximum efficiency* from the perspective of utilization of computer resources, primarily *CPU time and system memory*.
- Write code in a *readable and understandable* way and *comment* it well if necessary.
====

== Solution and submission

- All your *implementation* — that is, the definition of the `epc::optional` class template, its member functions, and corresponding free functions — create in the form of a *single header file* named `optional.h`.
- Inidividual development versions *subsequently store* into the *branch called _semwork_* of your *repository of the NIE-EPC course on the faculty GitLab instance*.
- *Link to this repozitory* is https://gitlab.fit.cvut.cz/NI-EPC/B211/USERNAME, where *USERNAME* is you faculty username.
- Keep the implemented header file `optional.h` directly inside *the root directory of the _semwork_ branch*.
- *Deadline for submission* of the semestral work is the end of the last week of the semester teaching period, namely, *Sunday, December the 19th* (included).

WARNING: The *final submission* is considered the *version of the `optional.h` header file present in the repozitory at this deadline date*. *Any further updates might not be taken into consideration for the classification.*

[CAUTION]
====
* *Part of the final course exam* will be also the *discussion about the submitted solution*.
* Substantial *suspicion of non-individual development* of the submitted solution may result in *loss of points* for classification of semestral work.
====

[NOTE]
.Use of faculty GitLab
====
- To use the gitlab.fit.cvut.cz server, a *user account* needs to be available there. Such an account should be available automatically to each student, who is *present in the USERMAP database*.
- *Uploading and updating of files* are possible either via *web interface* or via an *arbitrary GIT client program*. In the second case, the user needs to upload into the account settings their *SSH public keys* and the *corresponding private key* needs to be used for the communication with the server.
- *Updates of the source code* via the web interface works such that you use the *“Edit” button* and rewrite the source code by its new version. Then, *describe the changes into the “Commit message” text field* and, finally, use the *“Commit changes” button*.
- An alternative for the “Edit” button is to use the *“Replace” button*, which allows to *replace the actual version of the file by the new one*, uploaded from the client computer system. Even in this case, *describe the corresponding file changes*.
====

[IMPORTANT]
====
- Individual commits should reflect *logical develpment parts* and should be *commented* accordingly in the *“Commit message”* text field.

- Examples of *suitable comments*: _“implementation of copy constructor”_, _“buffer misalignment corrected”_, _“initial emplace funciton implementation”_, etc.
- Examples of *unsuitable comments*: _“file update”_, _“implementation of other functions”_, _“new version”_, etc.
- Commit comments as well as comments in the code should be written in *English or Czech language*.
====

== Hodnocení

* K hodnocení budou využity *testovací programy*, které ověří korektnost a funkčnost odevzdaného řešení.
* Pokud odevzdaný kód *nepůjde přeložit* (tj. překlad skončí s chybou), bude hodnocení provedeno *na základě „_code review_“* (tj. na základě jeho vizuálního prozkoumání).
** V takovém případě *nelze definovat objektivní kritéria pro bodové hodnocení*, a to bude tudíž provedeno *subjektivně bez jakýchkoliv bodových záruk*.
* V opačném případě bude hodnocení vycházet z *úspěšnosti odevzdaného řešení v rámci testovacích programů*.

== Aplikační programové rozhraní (API)

*Šablonová třída* `epc::optional`:

[source,c++]
----
// header file optional.h

namespace epc {

template <typename T>
class optional 
{
   ... // implementation to be made
};

... // free functions

} // namespace epc
----

=== Šablonové parametry

* `T` — *hodnotový typ (_value type_)*.

=== Veřejné členské typy

* `value_type` — *hodnotový typ* (_value type_) třídy (`T`).

=== Konstruktory a destruktor

* `optional()` — *výchozí konstruktor*. Konstruuje objekt, který *neobsahuje hodnotu*.

* `optional(const optional& other)` — *kopírovací konstruktor*.
** Pokud `other` *obsahuje hodnotu*, inicializuje hodnotu *pomocí výrazu `+*other+`*.
** Pokud `other` *neobsahuje hodnotu*, konstruuje objekt, který *neobsahuje hodnotu* (podobně jako výchozí konstruktor).

* `optional(optional&& other)` — *přesouvací konstruktor*.
** Pokud `other` *obsahuje hodnotu*, inicializuje hodnotu *pomocí výrazu `+std::move(*other)+`*.
** Pokud `other` *neobsahuje hondnotu*, konstruuje objekt, který *neobsahuje hodnotu* (podobně jako výchozí konstruktor).

* `+template <typename... Ts> optional(std::in_place_t, Ts&&... args)+` — konverzní konstruktor.
** Inicializuje hodnotu pomocí techniky *_perfect forwarding_ aplikované na argumenty* `+args...+`.

* `~optional()` — *destruktor*. 
** Pokud aktuální objekt (`+*this+`) obsahuje hodnotu, tak ji *zdestruuje*.
** V opačném případě neprovádí žádnou operaci.

=== Přiřazovací operátory

* `optional& operator=(const optional& other)` — *kopírovací přiřazovací operátor*.
** Pokud _zdrojový objekt_ (`other`) a _cílový objekt_ (`+*this+`) oba neobsahují hodnotu, nemá *žádný efekt*.
** Pokud _cílový objekt_ obsahuje hodnotu a _zdrojový objekt_ ji neobsahuje, je *hodnota _cílového objektu_ zdestruována*.
** Pokud _cílový objekt_ neobsahuje hodnotu a _zdrojový objekt_ ji obsahuje, *inicializuje hodnotu _cílového objektu_* pomocí výrazu `+*other+`.
** Pokud _zdrojový objekt_ i _cílový objekt_ oba obsahují hodnotu, je *hodnota _cílového objektu_ přiřazena hodnotě _zdrojového objektu_* pomocí výrazu `+= *other+`.
** Vrací referenci na sebe sama (_cílový objekt_).

* `optional& operator=(optional&& other)` — *přesouvací přiřazovací operátor*.
** Pokud _zdrojový objekt_ (`other`) a _cílový objekt_ (`+*this+`) oba neobsahují hodnotu, nemá *žádný efekt*.
** Pokud _cílový objekt_ obsahuje hodnotu a _zdrojový objekt_ ji neobsahuje, je *hodnota _cílového objektu_ zdestruována*.
** Pokud _cílový objekt_ neobsahuje hodnotu a _zdrojový objekt_ ji obsahuje, *inicializuje hodnotu _cílového objektu_* pomocí výrazu `+std::move(*other)+`.
** Pokud _zdrojový objekt_ i _cílový objekt_ oba obsahují hodnotu, je *hodnota _cílového objektu_ přiřazena hodnotě _zdrojového objektu_* pomocí výrazu `+= std::move(*other)+`.
** Vrací referenci na sebe sama (_cílový objekt_).

=== Ostatní členské funkce

* `+const T* operator->() const+` — vrací *ukazatel na obsaženou hodnotu*. V případě, že obsažená není, vede na *nedefinované chování*.
* `+T* operator->()+` — vrací *ukazatel na obsaženou hodnotu*. V případě, že obsažená není, vede na *nedefinované chování*.

* `+const T& operator*() const+` — vrací *referenci na obsaženou hodnotu*. V případě, že obsažená není, vede na *nedefinované chování*.
* `+T& operator*()+` — vrací *referenci na obsaženou hodnotu*. V případě, že obsažená není, vede na *nedefinované chování*.

* `operator bool() const` — vrací *`true` nebo `false`* v případě, že aktuální objekt (`+*this+`) *obsahuje nebo neobsahuje hodnotu*, v uvedeném pořadí.

* `void swap(optional& other)` — *prohození obsahu* _cílového objektu_ (`+*this+`) a _zdrojového objektu_ (`other`).
** Pokud _zdrojový objekt_ a _cílový objekt_ oba neobsahují hodnotu, nemá *žádný efekt*.
** Pokud _cílový objekt_ obsahuje hodnotu a _zdrojový objekt_ ji neobsahuje, nejprve *inicializuje hodnotu _zdrojového objektu_* pomocí výrazu `+std::move(**this)+` a poté *zdestruuje* hodnotu _cílového objektu_.
** Pokud _cílový objekt_ neobsahuje hodnotu a _zdrojový objekt_ ji obsahuje, nejprve *inicializuje hodnotu _cílového objektu_* pomocí výrazu `+std::move(*other)+` a poté *zdestruuje* hodnotu _zdrojového objektu_.
** Pokud _zdrojový objekt_ i _cílový objekt_ oba objekty obsahují hodnotu, *prohodí jejich obsah* voláním `+using std::swap; swap(**this, *other);+`.

* `void reset()`
** Pokud aktuální objekt (`+*this+`) obsahuje hodnotu, tak ji *zdestruuje*.
** Jinak nemá žádný efekt.

* `+template <typename... Ts> void emplace(Ts...&& args)+`
** Pokud aktuální objekt (`+*this+`) obsahuje hodnotu, tak ji nejprve *zdestruuje*.
** Poté inicializuje novou hodnotu pomocí techinky *_perfect forwarding_ aplikované na argumenty* `+args...+`.

=== Volné funkce

* `template <typename T> void swap(optional<T>& a, optional<T>& b)` — *prohození obsahu* objektů `a` a `b` (efektivně ekvivalentní s voláním `a.swap(b)`).

WARNING: Volné funkce se musí nacházet rovněž ve *jmenném prostoru* `epc`.