= Assignment 2

**Separation of memory (storage) allocation and deallocation from vector elements initialization and destruction.**

* High efficiency of vectors stems form the allocation of storage for multiple elements at once.
* The allocation itself does not create any elements; these are then in the allocated storage initialized as needed.
* In the same way, element destruction is separated from storage deallocation.

== Example 1

[source,c++]
----
{
  epc::vector<std::string> v; // <1>
  v.reserve(3); // <2>  
} // <3>
----

<1> A vector is created by the default constructor.
<2> The storage with the capacity 3 is allocated, i.e., the storage where 3 elements of the value type can be placed (next to each other).
<3> Vector destruction deallocates the storage allocated in the `reserve(3)` call.

IMPORTANT: In the shown code, there is no initialization (and destruction) of any objects of the value type `std::string`.

== Example 2

[source,c++]
----
{
  epc::vector<std::string> v; 
  v.reserve(3); 
  v.push_back(std::string("string literal")); // <1>
  v.pop_back(); // <2>
} 
----
<1> At the beginning of the allocated storage (“0th” position), a new element is initialized. The function argument is used as an initialization argument.
<2> The single vector element is destructed (by destructor).

NOTE: The other steps behave the same as in Example 1.

== Mechanisms

[IMPORTANT]
====
* Storage allocation for vector elements needs to involve a call of the `operator new` or `::operator new` allocation function (for the purposes of this programming assignment, there is no difference between these options).
* Deallocation of each allocated storage needs to involve call of the `operator delete` or `::operator delete`.
* Construction of each element needs to involve the use of _placement new_ with a suitable initialization expression.
* Destruction of each element needs to involve the _pseudo-destructor call_.
====

---

== Assignment

Implement the class template `vector` in the `epc` namespace with the following interface.

[source,c++]
----
template <typename T>
class vector
{
public:
  vector() noexcept; 

  vector(const vector&); 
  vector& operator=(const vector&); 

  ~vector();  

  T* data();  
  const T* data() const; 

  T& operator[](size_t); 
  const T& operator[](size_t) const; 

  void push_back(const T&); 
  void pop_back(); // <1>

  void clear(); // <2>

  void reserve(size_t); 

  size_t capacity() const; 
  size_t size() const; 

  void swap(vector&) noexcept;   
};
----
<1> Removal of the last element
<2> Removal of all elements

NOTE: Meaning of other member functions is the same as in Assignment 1.

NOTE: Details about the interface are in the following section.

== Application programming interface (API)

=== Template parameters

* `T` — *value type*
** Alignment requirements are `alignof(std::max_align_t)` at most (`T` is not _over-aligned_).
** The value type is destructible and destruction does not throw exceptions (_nothrow-destructible_).
** The value type is constructible by an initialization expression of type `T` (_copy-constructible_).
** Some member functions may specify additional requirements.
 
IMPORTANT: The value type does not need to be constructible without an initialization expression (_default-constructible_).

=== Special member functions

* `vector()` — *default constructor*
** Sets the vector into the empty state, i.e., state, where it does not contain any elements and its capacity is zero.
** Must not throw exceptions.

* `vector(const vector&)` — *copy constructor*
** The target vector have, after the operation, the same content (owned elements) as the source vector.
** The state of the source vector is not changed.
** Each element of the target vector is constructed as a copy of the corresponding element of the source vector.

* `operator=(const vector&)` — *copy assignment operator*
** The target vector have, after the operation, the same content (owned elements) as the source vector.
** The state of the source vector is not changed.
** The content of a target vector element is either assigned by the copy assignment operator or copied during its initialization.
** Requires the value type to be assignable by an expression of type `T` (_copy-assignable_).

IMPORTANT: Copy assignment operator needs to work even in the case where the source and target vectors represent the same object (so-called “self-assignment”).

* `~vector()` — *destructor*
** If needed, destructs all the vector elements and deallocates memory.

=== Elements access

* `data()` — *pointer to the first element*
** If the vector contains some elements, returns a pointer to the first of them.
** If the vector does not contain elements and its capacity is nonzero, returns a pointer to the allocated storage.
** If the vector does not contain elements and its capacity is zero, returns null pointer.

// NOTE: The function exits in two variants, i.e., as a _(non-constant) member function_ and a _constant member function_.

* `operator[]` — *reference to the desired element*
** If the vector contains the element with the index `i`, i.e., `i < size()` holds, returns a reference bound to this element.
** Otherwise, the behavior is undefined.

// NOTE: The operator exits in two variants, i.e., as a _(non-constant) member function_ and a _constant member function_.

=== Element insertion and removal

* `push_back(const T& value)` — *inserts element*
** Constructs, at the end of the vector (`data() + size()` address), a new element that is initialized by the expression `value`.
** If, before the element insertion, the size of the vector is equal to its capacity, extends its capacity first by performing “reallocation” according to the description of the `reserve()` function.
** In reallocation, the original capacity is generally doubled; only if it was zero, it is set to 1.

* `pop_back()` — *removes last element*
** If the vector is not empty, destructs its last element.
** Otherwise, the behavior is undefined.

IMPORTANT: If the vector is not empty, its capacity is preserved.

* `clear()` — *removes all elements*
** If the vector is not empty, destructs all its elements.

IMPORTANT: The capacity is preserved.

=== Extending capacity

* `reserve(size_t capacity)` — *extends vector capacity*
** If `capacity` is lower or equal to the actual vector's capacity, there are no effects.
** Otherwise, extends the capacity of the vector by performing “reallocation” and preserves its contents.
** Reallocation involves the following steps:
... New storage with the required capacity is allocated by the `operator new` allocation function.
... For each element in the original storage, its copy is constructed (initialized) in the new storage.
... The elements in the original storage are destructed and the original storage is deallocated.
... Internal vector variables are set such that the vector state corresponds with the new storage and its new capacity.

NOTE: For class types, copies are made by the copy constructor.

=== Information about vector

* `capacity()` — *information about capacity*
** Returns information about the vector’s capacity, i.e., the number of elments that fits into the storage last time allocated by `operator new`.

* `size()` — *information about element count*
** Returns information about the vector’s size, i.e., the number of elements that the vector contains/manages (i.e., that are in the actually allocated storage).

=== Swapping content

* `swap(vector& other)` — *swap contents of two vectors*
** Swaps content of two vectors, i.e., the vector `+*this+`, after the operation, will contain the same elements that the vector `other` had before, and vice versa.

IMPORTANT: This operation must not throw an exception.

== Exception handling

The rules from Assignment 1 applies.

---

== Requirements for implementation

The rules from the first practical assignment apply.

== Solution

A solution of the assigned programming task consists of two parts:

. the implementation of the `epc::vector` class template,
. the report from the measurement of its efficiency.

=== Implementation

The rules from the first practical assignment apply, except using the _practical3_ branch.

=== Efficiencny measurements

* Measure the efficiency of your implementation by the program with the source code in the `benchmark.cpp` file.
* Perform the measurements by building and running the program on the classroom computers where all the required libraries are available.
* Perform the mesurements separately for the benchmark program compiled by the GCC and Clang compilers.
* To build the benchmark program, you can use the `Makefile` file and `make benchmark-gcc` and `make benchmark-clang` commands.

==== Efficiency measurement report

* In the report, compare the measured times with the results obtained in the first assignment.
* Include also the results obtained for `std::vector`.
* This report will have the form of the “Description” field by the _merge request_ created for the submission of your solution.
* The report will contained the mesasured time (column “Time”) for inidividual vector implementations.
* The report will contain the results obtained for both compilers.

== Classification

* If the considered GitLab _job_ will even not be able to build the test program because of an incorrect implementation, the assignment will be classified with 0 points.
* In case that the compilation will succeed but some tests will not pass, the maximum amount of awarded points will be 5.
* In case that all tests will pass and the efficiency measurement report will be submitted, the maximum amount of classification points, i.e., 10, can be awarded.

---
