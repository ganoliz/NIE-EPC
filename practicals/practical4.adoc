= Practical 4.1

*Value pointer `ValuePtr`*

== Introduction

The standard {cpp} library contains only _smart pointers_ that are able to *copy or move the ownership of a particular object*. It does not contain any smart pointer that would be able to *create new objects* and, at the same time, to *copy or move their content*.

== Assignment

* *Implement the class template `ValuePtr`* that serves as a *smart pointer* with the ability to *create new objects with copying or moving their content*.
* The content of an object of the `ValuePtr<T>` class is the *ownership of an object of type `T`*.
* This ownership is *optional*, similarly as, for instance, with the library smart pointer `std::unique_ptr<T>`.
* The `ValuePtr` class template implement in the *`ValuePtr.h` header file*.

=== Class template interface

* `ValuePtr()` -- *default constructor*. Does not initialize any object of type `T`.

* `ValuePtr(T* ptr)` -- *converting constructor*. *Takes over ownership of the object* pointed-to by `ptr`.

CAUTION: It is assumed that the pointed-to object has been *initialized -- and its storage allocated -- by the `new` expression*.

* `ValuePtr(const ValuePtr& other)` -- *copy constructor*.
** If `other` *does not own any object of type `T`*, the constructed object `+*this+` will not own any object of type `T` as well.
** If `other` *does own and object of type `T`*, the constructed object `+*this+` will own an object of type `T` that will be initialized by *copying the content from `+*other+`*.

* `ValuePtr(ValuePtr&& other)` -- *move constructor*.
** If `other` *does not own any object of type `T`*, the constructed object `+*this+` will not own any object of type `T` as well.
** If `other` *does own and object of type `T`*, the constructed object `+*this+` will own an object of type `T` that will be initialized by *moving the content from `+*other+`*.

* `~ValuePtr()` -- *destructor*.
** If the destructed object `+*this+` *does own an object of type `T`*, it will be *destructed and its storage deallocated*.
** Otherwise, it has no effect.

* `T& operator*()` -- *dereference operator*. Returns a *reference to the owned object* if it does exist. Otherwise, causes undefined behavior.

* `+T* operator->()+` -- *member access operator*. Returns a *pointer to the owned object* if it does exist. Otherwise, causes undefined behavior.

* `T* get()` -- returns a *pointer to the owned object* if it does exist. *Otherwiser, returns `nullptr`*.

NOTE: For the sake of simplicity, the *copy assignment and move assignment operators are deleted.*

== Other requirements

* Dbejte na to, aby použití třídní šablony `ValuePtr` bylo *co nejefektivnější*, a to z pohledu *časových (procesorových) i paměťových zdrojů*.

[IMPORTANT]
====
* Pro implementaci *nepoužívejte žádné entity ze standardní knihovny C++* (ani z žádné jiné knihovny) *s výjimkou funkce (funkční šablony) `std::move`*.
====

CAUTION: Nijak *nemodifikujte obsah souboru se zdrojovým kódem testovacího programu* (viz níže).

=== Template

Pro implemnetaci můžete využít *šablonu definovanou následovně*:

[source,c++]
----
#ifndef VALUE_PTR_H
#define VALUE_PTR_H

template <typename T>
class ValuePtr
{

public:
    ValuePtr() { }

    ValuePtr(T* ptr) { }

    ValuePtr(const ValuePtr& other) { }

    ValuePtr(ValuePtr&& other) { }

    ~ValuePtr() { }

    ValuePtr& operator=(const ValuePtr&) = delete;
    ValuePtr& operator=(ValuePtr&&) = delete;

    T& operator*() { }

    T* operator->() { }

    T* get() { }
};

#endif
----

== Assignment

* Za *výsledné řešení* se považuje *obsah souboru `ValuePtr.h`* umístěného v *kořenovém adresáři větve _practical4_* vašeho *předmětového projektu/repozitáře* na *fakultní instanci GitLab*.
* Za *správné řešení* je považována *přeložitelná a funkční implementace* třídní šablony `ValuePtr` *dle zadání výše*.
* *Termín pro odevzdání* je *konec vašeho cvičení* (cvičení, které máte zapsané dle rozvrhu).

CAUTION: Úlohu je možné odevzat i do *24 hodin po termínu*; v takovém případě ale bude hodnocena *nejvýše 4 body*.

* Odezvdání realizujte formou *vytvoření požadavku _merge request_*, a to *z větve _practical4_ do větve _master_* v rámci vašeho projektu.

== Testing

* Pro účely testování bude použitý *program využívající framework Boost.Test*.
* Tento program bude *součástí vašeho projektu/repozitáře* a bude *automaticky přeložen a spouštěn při každé změně* v souborech ze zdrojovým kódem.
* Odkaz na šablonu projektu s testovacím programem do online IDE Godbolt: https://godbolt.org/z/eW5fPYfK6.
* Odkaz na šablonu projektu s testovacím programem do online IDE Wandbox: https://wandbox.org/permlink/lbpHEf26bsS8Bdxe.