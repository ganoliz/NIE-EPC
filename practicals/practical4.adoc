= Practical 4.1

*Value pointer `ValuePtr`*

== Introduction

The standard {cpp} library contains only _smart pointers_ that are able to *copy or move the ownership of a particular object*. It does not contain any smart pointer that would be able to *create new objects* and, at the same time, to *copy or move their content*.

== Assignment

* *Implement the class template `ValuePtr`* that serves as a *smart pointer* with the ability to *create new objects with copying or moving their content*.
* The content of an object of the `ValuePtr<T>` class is the *ownership of an object of type `T`*.
* This ownership is *optional*, similarly as, for instance, with the library smart pointer `std::unique_ptr<T>`.
* The `ValuePtr` class template implement in the *`ValuePtr.h` header file*.

=== Class template interface

* `ValuePtr()` -- *default constructor*. Does not initialize any object of type `T`.

* `ValuePtr(T* ptr)` -- *converting constructor*. *Takes over ownership of the object* pointed-to by `ptr`.

CAUTION: It is assumed that the pointed-to object has been *initialized -- and its storage allocated -- by the `new` expression*.

* `ValuePtr(const ValuePtr& other)` -- *copy constructor*.
** If `other` *does not own any object of type `T`*, the constructed object `+*this+` will not own any object of type `T` as well.
** If `other` *does own and object of type `T`*, the constructed object `+*this+` will own an object of type `T` that will be initialized by *copying the content from `+*other+`*.

* `ValuePtr(ValuePtr&& other)` -- *move constructor*.
** If `other` *does not own any object of type `T`*, the constructed object `+*this+` will not own any object of type `T` as well.
** If `other` *does own and object of type `T`*, the constructed object `+*this+` will own an object of type `T` that will be initialized by *moving the content from `+*other+`*.

* `~ValuePtr()` -- *destructor*.
** If the destructed object `+*this+` *does own an object of type `T`*, it will be *destructed and its storage deallocated*.
** Otherwise, it has no effect.

* `T& operator*()` -- *dereference operator*. Returns a *reference to the owned object* if it does exist. Otherwise, causes undefined behavior.

* `+T* operator->()+` -- *member access operator*. Returns a *pointer to the owned object* if it does exist. Otherwise, causes undefined behavior.

* `T* get()` -- returns a *pointer to the owned object* if it does exist. *Otherwiser, returns `nullptr`*.

NOTE: For the sake of simplicity, the *copy assignment and move assignment operators are deleted.*

== Other requirements

* Try to implement the `ValuePtr` class template such that it would be as *efficient as possible* from the perspective of *runtime and memory resources costs*.

[IMPORTANT]
====
* For implementation, *do not use any entities from the C++ standard library (nor any other library) with the *exception of the `std::move` function (template)*.
====

CAUTION: *Do not modify the content of the test program* (see below).

=== Template

For implementation, you can use the *following code template*:

[source,c++]
----
#ifndef VALUE_PTR_H
#define VALUE_PTR_H

template <typename T>
class ValuePtr
{

public:
    ValuePtr() { }

    ValuePtr(T* ptr) { }

    ValuePtr(const ValuePtr& other) { }

    ValuePtr(ValuePtr&& other) { }

    ~ValuePtr() { }

    ValuePtr& operator=(const ValuePtr&) = delete;
    ValuePtr& operator=(ValuePtr&&) = delete;

    T& operator*() { }

    T* operator->() { }

    T* get() { }
};

#endif
----

== Assignment

* As a *final solution*, it is considered the *content of the `ValuePtr.h` file* placed in the *root folder of the _practical4_ branch* of your *course project/repository* on *the faculty GitLab instance*.
* As a *correct solution*, it is considered a *compilable and working implementation* of the `ValuePtr` class template *according to the assignment above*,
* *The deadline for submission* is the *end of the week after the week with your practical class* (according to your time table).
* Register the submission by *creating the _merge request_*, namely *from the _practical4_ branch into the _master_ branch* inside your project.

== Testing

* For testing purposes, a *program based on the Boost.Test framework* will be available.
* This program is a *part of your project/repository* and will be *automatically compiled and executed after each change* in the source code files.
* A Godbolt online IDE link to the project template with the test program: https://godbolt.org/z/eW5fPYfK6.
* A Wandbox online IDE link to the project template with the test program: https://wandbox.org/permlink/lbpHEf26bsS8Bdxe.