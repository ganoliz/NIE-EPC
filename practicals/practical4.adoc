= Practical 4

**Small buffer optimization**

* Adding included storage (buffer) into vector with the capacity for `N` elements, where `N` is the second template parameter.
* The capacity of a default-constructed vector is `N`.
* Until the number of elements exceeds `N`, there is no need to dynamically allocate the storage for elements by the operator `new`.

IMPORTANT: This assignment follows the previous one; the most reqirements are the same.

== Examples

[source,c++]
----
epc::vector<int, 2> v; // <1>
v.push_back(1);  
v.push_back(2); // <2>  
v.push_back(3); // <3>
----

<1> An empty vector is constructed by the default constructor. Its capacity is 2.
<2> The vector contains 2 elements, both stored in the included storage (buffer).
<3> A new storage is dynamically allocated within reallocation. A new element is then inserted to its end.

== Mechanisms 

[IMPORTANT]
====
* For how to define the buffer, see, e.g., the exemplary implementation of the `optional` class template shown in lectures.
* Here, the difference is that the buffer needs to be sized for `N` elements.
====

== Assignment

Implement the class template `vector` in the `epc` namespace with the following interface and measure its efficiency:

[source,c++]
----
template <typename T, size_t N>
class vector
{
public:
  vector() noexcept; 

  vector(const vector&);
  vector& operator=(const vector&); 

  ~vector();  

  T* data();  
  const T* data() const; 

  T& operator[](size_t); 
  const T& operator[](size_t) const; 

  size_t capacity() const; 
  size_t size() const; 

  void reserve(size_t); 

  void push_back(const T&); 
  void pop_back();

  void clear(); 

  void swap(vector&) /* noexcept */ ;   
};
----

== Application programming interface (API)

IMPORTANT: Only the changes against the previous assignment are described.

CAUTION: For operations that work with two vectors, consider both having the same buffer capacity.

=== Template parameters

* `N` — *capcity of the included buffer
** `N` is greater then zero.

=== Special member functions

* `vector()` — *default constructor*
** Sets the vector into the empty state, i.e., state, where it does not contain any elements and its capacity is `N`.
** Must not throw exceptions.

=== Elements access

* `data()` — *pointer to the first element*
** If the vector contains some elements, returns a pointer to the first of them.
** If the vector does not contain any elements, returns a pointer to the allocated storage.

=== Information about vector

* `capacity()` — *information about capacity*
** Returns information about the vector’s capacity, i.e., the number of elments that fits into the actuall allocated storage.

NOTE: The actually allocated storage may also be the included buffer.

=== Swapping content

* `swap(vector& other)` — *swap contents of two vectors*
** Swaps content of two vectors, i.e., the vector `+*this+`, after the operation, will contain the same elements that the vector `other` had before, and vice versa.
** Requires the value type to be assignable by an expression of type `T` (_copy-assignable_).

== Exception handling

Within this assignment, no exception handling is required.

== Requirements for implementation

The rules from the first practical assignment apply.

== Solution

A solution of the assigned programming task consists of two parts:

. the implementation of the `epc::vector` class template,
. the report from the measurement of its efficiency.

=== Implementation

The rules from the first practical assignment apply, except using the _practical4_ branch.

=== Efficiencny measurements

* Measure the efficiency of your implementation by the program with the source code in the `benchmark.cpp` file.
* Perform the measurements by building and running the program on the classroom computers where all the required libraries are available.
* Perform the mesurements separately for the benchmark program compiled by the GCC and Clang compilers.
* To build the benchmark program, you can use the `Makefile` file and `make benchmark-gcc` and `make benchmark-clang` commands.

==== Efficiency measurement report

* Create a simple report with the results of efficiency measurements.
* This report will have the form of the “Description” field by the _merge request_ created for the submission of your solution.
* The report will contained the mesasured time (column “Time”) for all the vector implementations.
* The report will contain the results obtained for both compilers.

== Classification

* If the considered GitLab _job_ will even not be able to build the test program because of an incorrect implementation, the assignment will be classified with 0 points.
* In case that the compilation will succeed but some tests will not pass, the maximum amount of awarded points will be 5.
* In case that all tests will pass and the efficiency measurement report will be submitted, the maximum amount of classification points, i.e., 10, can be awarded.
