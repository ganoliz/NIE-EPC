= Practical 4

**Small buffer optimization**

* Adding included storage (buffer) into vector with the capacity for `N` elements, where `N` is the second template parameter.
* The capacity of a default-constructed vector is `N`.
* Until the number of elements exceeds `N`, there is no need to dynamically allocate the storage for elements by the operator `new`.

== Examples

[source,c++]
----
{
  epc::vector<int, 2> v; // <1>
  v.push_back(1);  
  v.push_back(2); // <2>  
  v.push_back(3); // <3>
} 
----

<1> An empty vector is constructed by the default constructor. Its capacity is 2.
<2> The vector contains 2 elements, both stored in the included storage (buffer).
<3> A new storage is dynamically allocated within reallocation. A new element is then inserted to its end.

== Mechanizmy

[IMPORTANT]
====
* Definice bufferu viz např. ukázková implementace třídní šablony `optional` na přednáškách.
* Zde je pouze na rozdíl od `optional` potřeba vytvořit buffer pro `N` prvků.
====

== Zadání

Implementujte třídní šablonu `vector` ve jmenném prostoru `epc` s následujícím rozhraním a změřte její efektivitu.

[source,c++]
----
template <typename T, size_t N>
class vector
{
public:
  vector() noexcept; 

  vector(const vector&);
  vector& operator=(const vector&); 

  ~vector();  

  T* data();  
  const T* data() const; 

  T& operator[](size_t); 
  const T& operator[](size_t) const; 

  size_t capacity() const; 
  size_t size() const; 

  void reserve(size_t); 

  void push_back(const T&); 
  void pop_back();

  void clear(); 

  void swap(vector&) /* noexcept */ ;   
};
----

== Aplikační programové rozhraní (API)

IMPORTANT: Jsou popsány pouze změny oproti předchozí úloze.

CAUTION: Pro operace, které pracují se dvěma vektory, uvažujte stejnou velikost vloženého bufferu.

=== Šablonové parametry

* `N` — *kapacita vloženého bufferu*

=== Speciální členské funkce

* `vector()` — *výchozí konstruktor*
** Nastaví vektor do prázdného stavu, tj. stavu, kdy neobsahuje žádné prvky a jeho kapacita je `N`.
** Nesmí vyhodit výjimku.

=== Přístup k prvkům

* `data()` — *ukazatel na první prvek*
** Pokud vektor obsahuje nějaké prvky, vrací ukazatel na první z nich. 
** Pokud vektor neobsahuje, vrací ukazatel na alokované uložiště.

=== Informace o vektoru

* `capacity()` — *informace o kapacitě*
** Vrátí informaci o kapacitě vektoru, tj. počtu prvků, které se vejdou do aktuálně alokovaného uložiště.

NOTE: Akutálním uložištěm může být i vložený buffer.

=== Prohození obsahu

* `swap(vector& other)` — *prohození obsahu*
** Prohodí obsah dvou vektorů, tj. vektor `+*this+` bude po operaci obsahovat stejné prvky, které měl před operací vektor `other`, a opačně.
** Vyžaduje hodnotový typ přiřaditelný výrazem, jehož typ je rovněž `T` (_copy-assignable_).

== Ošetřování výjimek

V rámci této úlohy není potřeba řešit korektní ošetřování výjimek.

== Požadavky na implementaci

Platí pravidla z první úlohy.

== Řešení

Řešení zadané úlohy se skládá ze dvou částí:

. implementace třídní šablony `epc::vector`,
. zprávy z měření efektivity této implementace.

=== Implementace

Platí pravidla z první úlohy až na použití větve _practical4_.

=== Měření efektivity

* Změřte efektivitu vaší implementace pomocí programu se zdrojovým kódem v souboru `benchmark.cpp`.
* Měření proveďte přeložením a spuštěním programu na učebnových počítačích, kde jsou veškeré potřebné knihovny dostupné.
* Měření proveďte zvlášť pro program přeložený pomocí překladačů GCC a Clang.
* Překlad lze provést za použití souboru `Makefile` příkazy `make benchmark-gcc a make benchmark-clang`.

==== Závěrečná zpráva z měření 

* Z výsledků měření efektivity vytvořte jednoduchou závěrečnou zprávu.
* Tuto zprávu realizujte formou popisu (pole „Description“) požadavku _merge requrest_ při odevzdání úlohy.
* Ve zprávě uveďte naměřené časy pro jednotlivé implementace vektoru ze sloupce „Time“.
* Do závěrečné zprávy uveďte výsledky měření pro oba překladače.

== Hodnocení

* Pokud se v rámci hodnocené GitLab _úlohy_ nepodaří testovací program vůbec přeložit kvůli chybám v implementaci, bude udělený počet bodů nulový.
* V případě, že překlad proběhne v pořádu, ale v testovacím programu skončí některé testy neúspěšně, bude uděleno maximálně 5 bodů.
* V případě, že překlad i testy dopadnou v pořádku a bude odevzdána zpráva z měření, může bý udělen až maximální počet bodu, tj. 10.
