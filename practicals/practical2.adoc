= Practical 2

**Adding copy semantics and other functionality, exception safety.**

CAUTION: This assignment follows the assignment from the first practical class; here, only the chagnes against the first assignment are present.

== Assignment

Implement the class template `vector` in the `epc` namespace with the following interface and make an analysis for the implementation of the copy assignment operator by the copy-and-swap idiom:

[source,c++]
----
template <typename T>
class vector
{
public:
  vector() noexcept; 

  vector(const vector&); // <1>
  vector& operator=(const vector&); // <2>

  ~vector();  

  T* data();  
  const T* data() const; 

  T& operator[](size_t); 
  const T& operator[](size_t) const; 

  void push_back(const T&); 

  size_t capacity() const; 
  size_t size() const; 

  void swap(vector&) noexcept; // <3>

  void reserve(size_t); // <4>

  void pop_back(); // <5>
};
----

<1> Copy constructor
<2> Copy assignment operator
<3> Content swapping
<4> Increasing capacity
<5> Reduction of size

NOTE: Details about the interface for the added or changed functionality are in the following section.

== Application programming interface (API)

CAUTION: For the parts of the interface that are not described, the rules from the first practical page hold, if not stated otherwise.

=== Special member functions

* `vector(const vector&)` — *copy constructor*
** The target vector have, after the operation, the same content (owned elements) as the source vector.
** The state of the source vector is not changed.

* `operator=(const vector&)` — *copy assignment operator*
** The target vector have, after the operation, the same content (owned elements) as the source vector.
** The state of the source vector is not changed.

IMPORTANT: Copy assignment operator needs to work even in the case where the source and target vectors represent the same object (so-called “self-assignment”).

=== Information about vector

* `capacity()` — *information about capacity*
** Returns information about the vector’s capacity, i.e., the size of the array that was last time allocated by the `new[]` expression.

* `size()` — *information about element count*
** Returns information about the vector’s size, i.e., the number of elements that the vector contains/manages.

=== Swapping content

* `swap(vector& other)` — *swap contents of two vectors*
** Swaps content of two vectors, i.e., the vector `+*this+`, after the operation, will contain the same elements that the vector `other` had before, and vice versa.

IMPORTANT: This operation must not throw an exception.

=== Extending capacity

* `reserve(size_t capacity)` — *extend vector capacity*
** If `capacity` is lower or equal to the actual vector's capacity, there are no effects.
** Otherwise, extends the capacity of the vector by performing “reallocation” (by the `new[]` expression) and preserves its contents.

=== Size reduction

* `pop_back()` — *reduces vector size*
** If the vector is non-empty, reduces its size by 1.
** Otherwise, the behavior is undefined.

IMPORTANT: The capcity of the vector may not be changed by this operation.

== Ošetřování výjimek

* Veškeré implementované operace vektoru musí provádět korektní ošetřování výjimek.

[WARNING]
====
* Pokud v nějaké operaci nastane výjimka, obsah zúčastněných vektorů musí být zachován.
* Toto pravidlo neplatí pouze pro kopírovací přiřazovací operátor.
====

IMPORTANT: Pokud je nějaká výjímka odchycena v rámci členské funkce vektoru, musí být dále propagována na místo volání této funkce.

== Copy-and-swap idiom

* Kopírovací přiřazovací operátor je možné implementovat pomocí tzv. „copy-and-swap“ idiomu.
* Ten deleguje kopírovací funkcionalitu na kopírovací konstruktor.
* Otázkou je, zda takovéto řešení bude ve všech případech efektivní.

== Požadavky na implementaci

* Platí pravidla z první úlohy.

== Řešení

* Řešení zadané úlohy se skládá ze dvou částí:
.. implementace třídní šablony `epc::vector`,
.. analýza efektivity implementace kopírovacího přiřazovacího operátoru pomocí copy-and-swap idiomu.

=== Implementace

Platí pravidla z první úlohy až na použití větve _practical2_.

=== Analáza efektivity copy-and-swap idiomu

* V rámci závěrečné zprávy popiště, zda implementace kopírovacího přiřazovacího operátoru pomocí copy-and-swap idiomu je nejefektivnější možná ve všech případech.
* Tyto případy zahrnují především různé kombinace velikostí a kapacit zdrojového a cílového vektoru.
* Zprávu realizujte formou popisu (pole „Description“) požadavku _merge requrest_ při odevzdání úlohy.

== Hodnocení

* Pokud se v rámci hodnocené GitLab _úlohy_ nepodaří testovací program vůbec přeložit kvůli chybám v implementaci, bude udělený počet bodů nulový.
* V případě, že překlad proběhne v pořádu, ale v testovacím programu skončí některé testy neúspěšně, bude uděleno maximálně 5 bodů.
* V případě, že překlad i testy dopadnou v pořádku, bude odevzdána zpráva a její závěry budou správné, může bý udělen až maximální počet bodu, tj. 10.
