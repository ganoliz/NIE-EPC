= Practical 2

*Pointer to IMPLementation (PIMPL)*

== Introduction

Consider the following implementation of the `LookupTable` class representing a *simple lookup table* that maps integers to strings. The implementation is split between:

. `LookupTable.h` *header file*, which contains the *class definition*:

[source,c++]
----
#ifndef LOOKUPTABLE_H
#define LOOKUPTABLE_H

#include <cstdlib>
#include <map>
#include <string>

class LookupTable
{
    std::map<int, std::string> data_;
    
public:
    LookupTable() = default;
    ~LookupTable() = default;
    
    // copy and move semantics deleted for sake of simplicity:
    LookupTable(const LookupTable&) = delete;
    LookupTable(LookupTable&&) = delete;
    LookupTable& operator=(const LookupTable&) = delete;
    LookupTable& operator=(LookupTable&&) = delete;
    
    void insert(int key, const std::string& name);
    void remove(int key);
    
    const std::string* name(int key) const;
    
    size_t count() const;
    void clear();
};

#endif
----

[start=2]
. `LookupTable.cpp` *source file*, which contains *definitions of member functions*:

[source,c++]
----
#include <cstdlib>
#include <string>

#include "LookupTable.h"

void LookupTable::insert(int key, const std::string& name)
{
    data_.insert(std::make_pair(key, name));
}

void LookupTable::remove(int key)
{
    data_.erase(key);
}

const std::string* LookupTable::name(int key) const
{
    auto iter = data_.find(key);
    if (iter != data_.end())
       return &(iter->second);
    else       
       return nullptr;
}

size_t LookupTable::count() const
{
    return data_.size();
}

void LookupTable::clear() 
{
    data_.clear();
}
----

== Assignment

. *Modify the content * of `LookupTable.h` and `LookupTable.cpp` files such that the `LookupTable` class was *implemented by the PIMPL idiom*. 

.Requiremetns for implementation
[IMPORTANT]
====
* *Definition of the interface class* called `LookupTable` will contain only a *single non-public member variable*, namely a pointer to the implementation class object.
* Except this variable, the class *may have no non-public member functions and variables*.
* Definition of a *non-public member type is allowed*.
====

[NOTE]
====
* You may use either an *“ordinary” (_raw_) pointer* or a *smart pointer* of type `std::unique_ptr`.
* In case of using a *smart pointer*, the implementation may be *more complex* (see, e.g., https://stackoverflow.com/q/9020372/580083[this post]).
====

[start=2]
. *Verify the functionality of your solution* such that you *change the type for the lookup table container* from  `std::map<int, std::string>` to `std::unordered_map<int, std::string>`.

WARNING: Don't forget that this update will require also an *update of included header files*.

IMPORTANT: With the correctly working PIMPL idiom, this update *must not require any modificatoin of the `LookupTable.h` header file*.

[start=3]
. From the `LookupTable.h` header file *remove* all *header files inclusion* (`#include` directives) that, are *unnecessary* after the PIMPL idiom implementation.

== Submission

* Za *výsledné řešení* se považuje *obsah souborů `LookupTable.h` a `LookupTable.cpp`* umístěných v *kořenovém adresáři větve _practical2_* vašeho *předmětového projektu/repozitáře* na *fakultní instanci GitLab*.
* Za *správné řešení* je považována:
** *přeložitelná a funkční implementace* třídy `LookupTable` pomocí PIMPL idiomu *dle zadání výše*,
** s *interně využitým kontejnerem typu* `std::unordered_map<int, std::string>`,
** s *odstraněnými nepotřebnými vkládanými hlavičkovými soubory* z hlavičkového souboru `LookupTable.h`.
* *Termín pro odevzdání* je *konec vašeho cvičení* (cvičení, které máte zapsané dle rozvrhu).
* Odezvdání realizujte formou *vytvoření požadavku _merge request_*, a to *z větve _practical2_ do větve _master_* v rámci vašeho projektu.

NOTE: U nastavení požadavku _merge request_ *ponechte pole _Assignee_ prázdné* (nepřiřazujte zde nikoho konkrétního).

== Testování

* Pro účely testování bude použitý *program využívající framework Boost.Test*.
* Tento program bude *součástí vašeho projektu/repozitáře* a bude *automaticky přeložen a spouštěn při každé změně* v souborech ze zdrojovým kódem.

[NOTE]
====
Pro *práci na řešení s využitím testovacího programu* jsou k dispozici následující základní možnosti:

* Vývoj na *soukromém počítači* s instalovanou knihovnou Boost.
* Vývoj přímo *v rámci GitLab projektu* s testováním pomocí *CI/CD mechanizmu* (_pipelines_, _jobs_),
* Vývoj v *online IDE Godbolt* (odkaz na šablonu: https://godbolt.org/z/b473eqvev),
* Vývoj v *online IDE Wandbox* (odkaz na šablonu: https://wandbox.org/permlink/4CQ3NGLligC8wzit).
====

* Testovací program primárně funguje *funkčnost implementace třídy*.
* Tato funkčnost musí být *zachována v celém rozsahu* při reimplementaci třídy pomocí PIMPL idiomu.
* Součástí programu jsou i *dva testy na velikost uložiště třídy `LookupTable`*:
** *První* testuje, zda třída obsahuje *členskou proměnnou typu `std::map<int, std::string>*.` Tento test *musí být*:
*** *úspěšný* pro *originální verzi třídy*,
*** *neúspěšný* pro *odevzdanou verzi třídy*.
** *Druhý* testuje, zda třída obsahuje pouze *jedinou členskou proměnnou typu ukazatel*.` Tento test *musí být*:
*** *neúspěšný* pro *originální verzi třídy*,
*** *úspěšný* pro *odevzdanou verzi třídy*.