= Practical 2

**Adding copy semantics and other functionality, exception safety.**

CAUTION: This assignment follows the assignment from the first practical class; here, only the chagnes against the first assignment are present.

== Assignment

Implement the class template `vector` in the `epc` namespace with the following interface and make an analysis for the implementation of the copy assignment operator by the copy-and-swap idiom:

[source,c++]
----
template <typename T>
class vector
{
public:
  vector() noexcept; 

  vector(const vector&); // <1>
  vector& operator=(const vector&); // <2>

  ~vector();  

  T* data();  
  const T* data() const; 

  T& operator[](size_t); 
  const T& operator[](size_t) const; 

  void push_back(const T&); 

  size_t capacity() const; 
  size_t size() const; 

  void swap(vector&) noexcept; // <3>

  void reserve(size_t); // <4>

  void pop_back(); // <5>
};
----

<1> Copy constructor
<2> Copy assignment operator
<3> Content swapping
<4> Increasing capacity
<5> Reduction of size

NOTE: Details about the interface for the added or changed functionality are in the following section.

== Application programming interface (API)

CAUTION: For the parts of the interface that are not described, the rules from the first practical page hold, if not stated otherwise.

=== Special member functions

* `vector(const vector&)` — *copy constructor*
** The target vector have, after the operation, the same content (owned elements) as the source vector.
** The state of the source vector is not changed.

* `operator=(const vector&)` — *copy assignment operator*
** The target vector have, after the operation, the same content (owned elements) as the source vector.
** The state of the source vector is not changed.

IMPORTANT: Copy assignment operator needs to work even in the case where the source and target vectors represent the same object (so-called “self-assignment”).

=== Information about vector

* `capacity()` — *information about capacity*
** Returns information about the vector’s capacity, i.e., the size of the array that was last time allocated by the `new[]` expression.

* `size()` — *information about element count*
** Returns information about the vector’s size, i.e., the number of elements that the vector contains/manages.

=== Swapping content

* `swap(vector& other)` — *swap contents of two vectors*
** Swaps content of two vectors, i.e., the vector `+*this+`, after the operation, will contain the same elements that the vector `other` had before, and vice versa.

IMPORTANT: This operation must not throw an exception.

=== Extending capacity

* `reserve(size_t capacity)` — *extend vector capacity*
** If `capacity` is lower or equal to the actual vector's capacity, there are no effects.
** Otherwise, extends the capacity of the vector by performing “reallocation” (by the `new[]` expression) and preserves its contents.

=== Size reduction

* `pop_back()` — *reduces vector size*
** If the vector is non-empty, reduces its size by 1.
** Otherwise, the behavior is undefined.

IMPORTANT: The capcity of the vector may not be changed by this operation.

== Exception handling

* All the implemented vector operations guarantee correct exception handling.

[WARNING]
====
* If, in some operation, an exception occurs, the content of involved vectors may not be changed.
* This rule does not hold only for the copy assignment operator.
====

IMPORTANT: If an exception is caught in some vector member function, it needs to be rethrown to the function caller.

== Copy-and-swap idiom

* Copy assignment operator may be implemented by the “copy-and-swap” idiom.
* This idiom delegates the copy functionality to the copy constructor.
* The question is whether such a solution would be efficient in all cases.

== Requirements for implementation

* The rules from the first practical assignment apply.

== Solution

* A solution of the assigned programming task consists of two parts:
.. the implementation of the `epc::vector` class template,
.. the analysis of the efficiency of the implementation of the copy assignment operator by the copy-and-swap idiom.

=== Implementation

The rules from the first practical assignment apply, except using the _practical2_ branch.

=== Analysis of the copy-and-swap idiom efficiency

* In the final report, describe whether the implementation of the copy assignment operator in terms of the copy-and-swap idiom is the most efficient in all cases.
* These cases contain mainly different combinations of the size and capacity of the source and target vectors.
* This report will have the form of the “Description” field by the _merge request_ created for the submission of your solution.

== Classification

* If the considered GitLab _job_ will even not be able to build the test program because of an incorrect implementation, the assignment will be classified with 0 points.
* In case that the compilation will succeed but some tests will not pass, the maximum amount of awarded points will be 5.
* In case that all tests will pass, the report will be submitted, and its conclusions will be correct, the maximum amount of classification points, i.e., 10, can be awarded.
