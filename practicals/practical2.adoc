= Practical 2

*Pointer to IMPLementation (PIMPL)*

== Introduction

Consider the following implementation of the `LookupTable` class representing a *simple lookup table* that maps integers to strings. The implementation is split between:

. `LookupTable.h` *header file*, which contains the *class definition*:

[source,c++]
----
#ifndef LOOKUPTABLE_H
#define LOOKUPTABLE_H

#include <cstdlib>
#include <map>
#include <string>

class LookupTable
{
    std::map<int, std::string> data_;
    
public:
    LookupTable() = default;
    ~LookupTable() = default;
    
    // copy and move semantics deleted for sake of simplicity:
    LookupTable(const LookupTable&) = delete;
    LookupTable(LookupTable&&) = delete;
    LookupTable& operator=(const LookupTable&) = delete;
    LookupTable& operator=(LookupTable&&) = delete;
    
    void insert(int key, const std::string& name);
    void remove(int key);
    
    const std::string* name(int key) const;
    
    size_t count() const;
    void clear();
};

#endif
----

[start=2]
. `LookupTable.cpp` *source file*, which contains *definitions of member functions*:

[source,c++]
----
#include <cstdlib>
#include <string>

#include "LookupTable.h"

void LookupTable::insert(int key, const std::string& name)
{
    data_.insert(std::make_pair(key, name));
}

void LookupTable::remove(int key)
{
    data_.erase(key);
}

const std::string* LookupTable::name(int key) const
{
    auto iter = data_.find(key);
    if (iter != data_.end())
       return &(iter->second);
    else       
       return nullptr;
}

size_t LookupTable::count() const
{
    return data_.size();
}

void LookupTable::clear() 
{
    data_.clear();
}
----

== Assignment

. *Modify the content * of `LookupTable.h` and `LookupTable.cpp` files such that the `LookupTable` class was *implemented by the PIMPL idiom*. 

.Requiremetns for implementation
[IMPORTANT]
====
* *Definition of the interface class* called `LookupTable` will contain only a *single non-public member variable*, namely a pointer to the implementation class object.
* Except this variable, the class *may have no non-public member functions and variables*.
* Definition of a *non-public member type is allowed*.
====

[NOTE]
====
* You may use either an *“ordinary” (_raw_) pointer* or a *smart pointer* of type `std::unique_ptr`.
* In case of using a *smart pointer*, the implementation may be *more complex* (see, e.g., https://stackoverflow.com/q/9020372/580083[this post]).
====

[start=2]
. *Verify the functionality of your solution* such that you *change the type for the lookup table container* from  `std::map<int, std::string>` to `std::unordered_map<int, std::string>`.

WARNING: Don't forget that this update will require also an *update of included header files*.

IMPORTANT: With the correctly working PIMPL idiom, this update *must not require any modificatoin of the `LookupTable.h` header file*.

[start=3]
. From the `LookupTable.h` header file *remove* all *header files inclusion* (`#include` directives) that, are *unnecessary* after the PIMPL idiom implementation.

== Submission

* As a *finel solution* is considered the *content of `LookupTable.h` and `LookupTable.cpp` files* placed in the *root folder of the _practical2_ branch* of your *course project/repository* on *the faculty GitLab instance*.
* As s *correct solution* is considered:
** *compilable and working implementation* of the `LookupTable` class with the PIMPL idiom *according to the assignment above*,
** with *internally used container of type* `std::unordered_map<int, std::string>`,
** with *removed all unnecessary inclusion of header files* from the `LookupTable.h` header file.
* *The deadline for submission* is the *end of your practical class* (class according to your time table).
* Register the submissing by *creating the _merge request_*, namely *from the _practical2_ branch into the _master_ branch* inside your project.

NOTE: In the _merge request_ configuration, *leave the _Assignee_ field empty* (do not assign here anyone).

== Testing

* Pro účely testování bude použitý *program využívající framework Boost.Test*.
* Tento program bude *součástí vašeho projektu/repozitáře* a bude *automaticky přeložen a spouštěn při každé změně* v souborech ze zdrojovým kódem.

[NOTE]
====
Pro *práci na řešení s využitím testovacího programu* jsou k dispozici následující základní možnosti:

* Vývoj na *soukromém počítači* s instalovanou knihovnou Boost.
* Vývoj přímo *v rámci GitLab projektu* s testováním pomocí *CI/CD mechanizmu* (_pipelines_, _jobs_),
* Vývoj v *online IDE Godbolt* (odkaz na šablonu: https://godbolt.org/z/b473eqvev),
* Vývoj v *online IDE Wandbox* (odkaz na šablonu: https://wandbox.org/permlink/4CQ3NGLligC8wzit).
====

* Testovací program primárně funguje *funkčnost implementace třídy*.
* Tato funkčnost musí být *zachována v celém rozsahu* při reimplementaci třídy pomocí PIMPL idiomu.
* Součástí programu jsou i *dva testy na velikost uložiště třídy `LookupTable`*:
** *První* testuje, zda třída obsahuje *členskou proměnnou typu `std::map<int, std::string>*.` Tento test *musí být*:
*** *úspěšný* pro *originální verzi třídy*,
*** *neúspěšný* pro *odevzdanou verzi třídy*.
** *Druhý* testuje, zda třída obsahuje pouze *jedinou členskou proměnnou typu ukazatel*.` Tento test *musí být*:
*** *neúspěšný* pro *originální verzi třídy*,
*** *úspěšný* pro *odevzdanou verzi třídy*.