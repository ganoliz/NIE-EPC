= Practical 2

*Pointer to IMPLementation (PIMPL)*

== Introduction

Consider the following implementation of the `LookupTable` class representing a *simple lookup table* that maps integers to strings. The implementation is split between:

. `LookupTable.h` *header file*, which contains the *class definition*:

[source,c++]
----
#ifndef LOOKUPTABLE_H
#define LOOKUPTABLE_H

#include <cstdlib>
#include <map>
#include <string>

class LookupTable
{
    std::map<int, std::string> data_;
    
public:
    LookupTable() = default;
    ~LookupTable() = default;
    
    // copy and move semantics deleted for sake of simplicity:
    LookupTable(const LookupTable&) = delete;
    LookupTable(LookupTable&&) = delete;
    LookupTable& operator=(const LookupTable&) = delete;
    LookupTable& operator=(LookupTable&&) = delete;
    
    void insert(int key, const std::string& name);
    void remove(int key);
    
    const std::string* name(int key) const;
    
    size_t count() const;
    void clear();
};

#endif
----

[start=2]
. `LookupTable.cpp` *source file*, which contains *definitions of member functions*:

[source,c++]
----
#include <cstdlib>
#include <string>

#include "LookupTable.h"

void LookupTable::insert(int key, const std::string& name)
{
    data_.insert(std::make_pair(key, name));
}

void LookupTable::remove(int key)
{
    data_.erase(key);
}

const std::string* LookupTable::name(int key) const
{
    auto iter = data_.find(key);
    if (iter != data_.end())
       return &(iter->second);
    else       
       return nullptr;
}

size_t LookupTable::count() const
{
    return data_.size();
}

void LookupTable::clear() 
{
    data_.clear();
}
----

== Assignment

. *Modify the content* of `LookupTable.h` and `LookupTable.cpp` files such that the `LookupTable` class was *implemented by the PIMPL idiom*. 

.Requiremetns for implementation
[IMPORTANT]
====
* *Definition of the interface class* called `LookupTable` will contain only a *single non-public member variable*, namely a pointer to the implementation class object.
* Except this variable, the class *may have no non-public member functions and variables*.
* Definition of a *non-public member type is allowed*.
====

[NOTE]
====
* You may use either an *“ordinary” (_raw_) pointer* or a *smart pointer* of type `std::unique_ptr`.
* In case of using a *smart pointer*, the implementation may be *more complicated* (see, e.g., https://stackoverflow.com/q/9020372/580083[this post]).
====

[start=2]
. *Verify the functionality of your solution* such that you *change the type for the lookup table container* from  `std::map<int, std::string>` to `std::unordered_map<int, std::string>`.

WARNING: Don't forget that this update will require also an *update of included header files*.

IMPORTANT: With the correctly working PIMPL idiom, this update *must not require any modification of the `LookupTable.h` header file*.

[start=3]
. *Remove* from the `LookupTable.h` header file all *header files inclusion* (`#include` directives) that are *unnecessary* after the PIMPL idiom implementation.

== Submission

* As a *final solution*, it is considered the *content of `LookupTable.h` and `LookupTable.cpp` files* placed in the *root folder of the _practical2_ branch* of your *course project/repository* on *the faculty GitLab instance*.
* As a *correct solution*, it is considered:
** a *compilable and working implementation* of the `LookupTable` class with the PIMPL idiom *according to the assignment above*,
** with *internally used container of type* `std::unordered_map<int, std::string>`,
** with *removed all unnecessary inclusion of header files* from the `LookupTable.h` header file.
* *The deadline for submission* is the *end of your practical class* (according to your time table).
* Register the submission by *creating the _merge request_*, namely *from the _practical2_ branch into the _master_ branch* inside your project.

NOTE: In the _merge request_ configuration, *leave the _Assignee_ field empty* (do not assign here anyone).

== Testing

* For testing purposes, a *program based on the Boost.Test framework* will be available.
* This program is a *part of your project/repository* and will be *automatically compiled and executed after each change* in the source code files.

[NOTE]
====
There are the following basic options for *using the test file during soluton development*:

* Development on you *private computer* with installed Boost.
* Direct development *inside the GitLab project* with the help of the *CI/CD mechanism* (_pipelines_, _jobs_),
* Development in the *online IDE Godbolt* (link to the template: https://godbolt.org/z/b473eqvev),
* Development in the *online IDE Wandbox* (link to the template: https://wandbox.org/permlink/4CQ3NGLligC8wzit).
====

* The test program primarily tests the *functionality of the class implementation*.
* This functionality needs to be *fully preserved* while reimplementing the class by the PIMPL idiom.
* A part of the test program are additionally *two tests for the byte size of the storage of the `LookupTable` class*:
** The *first* one tests if the class contains a *member variable of the `std::map<int, std::string> type*.` This test *needs to*:
*** *pass* for the *original class version*,
*** *fail* for the *submitted class version*.
** The *second* one tests if the class contains only a *single pointer member variable*.` This test *needs to*:
*** *fail* for the *original class version*,
*** *pass* for the *submitted class version*.