= Practical 2

**Adding copy semantics and other functionality, exception safety.**

CAUTION: This assignment follows the assignment from the first practical class; here, only the chagnes against the first assignment are present.

== Zadání

Implementujte třídní šablonu `vector` ve jmenném prostoru `epc` s následujícím rozhraním a proveďte analýzu implementace kopírovacího přiřazovacího operátoru pomocí copy-and-swap idiomu:

[source,c++]
----
template <typename T>
class vector
{
public:
  vector() noexcept; 

  vector(const vector&); // <1>
  vector& operator=(const vector&); // <2>

  ~vector();  

  T* data();  
  const T* data() const; 

  T& operator[](size_t); 
  const T& operator[](size_t) const; 

  void push_back(const T&); 

  size_t capacity() const; 
  size_t size() const; 

  void swap(vector&) noexcept; // <3>

  void reserve(size_t); // <4>

  void pop_back(); // <5>
};
----

<1> Kopírovací konstruktor
<2> Kopírovací přiřazovací operátor
<3> Prohození obsahu 
<4> Navýšení kapacity
<5> Snížení velikosti

NOTE: Podrobné informace o rozhraní pro přidanou či změněnou funkcionalitu jsou uvedeny v následující sekci.

== Aplikační programové rozhraní (API)

CAUTION: Pro součásti rozhraní, které zde nejsou popsány, platí popis ze stránky prvního cvičení, pokud není uvedeno jinak.

=== Konstruktory a destruktor

* `vector(const vector&)` — *kopírovací konstruktor*
** Cílový vektor bude mít po operaci stejný obsah (vlastněné prvky), jako zdrojový vektor.
** Stav zdrojového vektoru nesmí být změněn.

* `operator=(const vector&)` — *kopírovací přiřazovací operátor*
** Cílový vektor bude mít po operaci stejný obsah (vlastněné prvky), jako zdrojový vektor.
** Stav zdrojového vektoru nesmí být změněn.

IMPORTANT: Kopírovací přiřazovací operátor musí fungovat i v případě, že zdrojový a cílový vektor představují stejný objekt (tzv. „self-assignment“).

=== Informace o vektoru

* `capacity()` — *informace o kapacitě*
** Vrátí informaci o kapacitě vektoru, tj. velikosti pole naposledy alokovaného pomocí výrazu `new[]`.

* `size()` — *informace o počtu prvků*
** Vrátí informaci o velikosti vektoru, tj. počtu prvků, které vektor obsahuje/spravuje.

=== Prohození obsahu

* `swap(vector& other)` — *prohození obsahu*
** Prohodí obsah dvou vektorů, tj. vektor `+*this+` bude po operaci obsahovat stejné prvky, které měl před operací vektor `other`, a opačně.

IMPORTANT: Tato operace nesmí vyhodit výjimku.

=== Navýšení kapacity

* `reserve(size_t capacity)` — *navýšení kapacity*
** Pokud `capacity` je menší nebo rovno aktální kapacitě vektoru, nemá žádný efekt.
** V opačném případě pomocí „realokace“ navýší kapacitu vektoru na `capacity` (pomocí výrazu `new[]`) a zachová jeho obsah.

=== Snížení velikosti

* `pop_back()` — *snížení velikosti*
** Pokud vektor není prázdný, sníží jeho velikost o 1.
** V opačném případě není chování definováno.

IMPORTANT: Kapacita vektoru v rámci této operace musí být zachována.

== Ošetřování výjimek

* Veškeré implementované operace vektoru musí provádět korektní ošetřování výjimek.

[WARNING]
====
* Pokud v nějaké operaci nastane výjimka, obsah zúčastněných vektorů musí být zachován.
* Toto pravidlo neplatí pouze pro kopírovací přiřazovací operátor.
====

IMPORTANT: Pokud je nějaká výjímka odchycena v rámci členské funkce vektoru, musí být dále propagována na místo volání této funkce.

== Copy-and-swap idiom

* Kopírovací přiřazovací operátor je možné implementovat pomocí tzv. „copy-and-swap“ idiomu.
* Ten deleguje kopírovací funkcionalitu na kopírovací konstruktor.
* Otázkou je, zda takovéto řešení bude ve všech případech efektivní.

== Požadavky na implementaci

* Platí pravidla z první úlohy.

== Řešení

* Řešení zadané úlohy se skládá ze dvou částí:
.. implementace třídní šablony `epc::vector`,
.. analýza efektivity implementace kopírovacího přiřazovacího operátoru pomocí copy-and-swap idiomu.

=== Implementace

Platí pravidla z první úlohy až na použití větve _practical2_.

=== Analáza efektivity copy-and-swap idiomu

* V rámci závěrečné zprávy popiště, zda implementace kopírovacího přiřazovacího operátoru pomocí copy-and-swap idiomu je nejefektivnější možná ve všech případech.
* Tyto případy zahrnují především různé kombinace velikostí a kapacit zdrojového a cílového vektoru.
* Zprávu realizujte formou popisu (pole „Description“) požadavku _merge requrest_ při odevzdání úlohy.

== Hodnocení

* Pokud se v rámci hodnocené GitLab _úlohy_ nepodaří testovací program vůbec přeložit kvůli chybám v implementaci, bude udělený počet bodů nulový.
* V případě, že překlad proběhne v pořádu, ale v testovacím programu skončí některé testy neúspěšně, bude uděleno maximálně 5 bodů.
* V případě, že překlad i testy dopadnou v pořádku, bude odevzdána zpráva a její závěry budou správné, může bý udělen až maximální počet bodu, tj. 10.

---

== Bonusový volitelný problém

* Kód pro numerický výpočet hodnoty dvojitého integrálu dává odlišný výsledek v případě volby jednoduché a dvojíté přesnosti.
* Zjistěte příčinu tohoto chování.
* Kód a live demo: https://godbolt.org/z/Yo4ncqxb7
* Počítaný integrál:

[stem]
++++
\int\limits_{3.7}^{4.3} \int\limits_{2.3}^{2.5} \sqrt{x^4 + y^5} \, \mathrm{d}x\, \mathrm{d}y = 3.9159
++++

NOTE: Správnou hodnotu dává výpočet v jednoduché přesnosti! Viz např. https://www.wolframalpha.com/input?i=int+%28%28x%5E4%2By%5E5%29%5E%281%2F2%29%29+dx+dy%2C+y%3D3.7+to+4.3%2C+x%3D2.3+to+2.5[zde].
