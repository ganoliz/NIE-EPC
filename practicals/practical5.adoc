= Practical 4.2

*Assignment operators*

== Introduction

*Assignment operators* can be implemented in *different forms*. Let us consider the following implementation of the *value pointer `ValuePtr<T>`*:

[source,c++]
----
template <typename T>
class ValuePtr {
  T* ptr_;
  
public:
  ValuePtr() : ptr_(nullptr) { }
  ValuePtr(T* ptr) : ptr_(ptr) { }
  
  ValuePtr(const ValuePtr& other) ... // implemented in Practical 4.1 assignment

  ValuePtr(ValuePtr&& other) ... // implemented in Practical 4.1 assignment

  ~ValuePtr() ... // implemented in Practical 4.1 assignment
  
  void swap(ValuePtr& other) { std::swap(ptr_, other.ptr_); }

  ...  // other member functions
};
----

=== Case 1

*Basic „direct“ implementation of assignment operators* could look like as follows:

[source,c++]
----
ValuePtr& operator=(const ValuePtr& other) {
  if (this != &other) {
    if (ptr_ && other.ptr_) *ptr_ = *other.ptr_;
    else if (other.ptr_) ptr_ = new T(*other.ptr_);
    else if (ptr_) { delete ptr_; ptr_ = nullptr; }
  }
  return *this;
}

ValuePtr& operator=(ValuePtr&& other) {
  if (this != &other) {
    if (ptr_ && other.ptr_) *ptr_ = std::move(*other.ptr_);
    else if (other.ptr_) ptr_ = new T(std::move(*other.ptr_));
    else if (ptr_) { delete ptr_; ptr_ = nullptr_; }
  }
  return *this;
}
----

=== Case 2

Another option is to implement both operators by the *copy-and-swap (C&S) idiom*:

[source,c++]
----
ValuePtr& operator=(const ValuePtr& other) {
  ValuePtr temp(other);
  swap(temp);
  return *this;
}

ValuePtr& operator=(ValuePtr&& other) {
  ValuePtr temp(std::move(other));
  swap(temp);
  return *this;
}
----

=== Case 3 

The third option is to combine both operators into so-called *unified/unifying assignment operator*, where the role of the auxiliary object `temp` is represented by the *operator parameter*:

[source,c++]
----
ValuePtr& operator=(ValuePtr other) {
  swap(other);
  return *this;
}
----

NOTE: The unified assignment operator is technically a *form of the copy assignment operator*.

== Assignment

=== Part I.

* Find out whether the above-introduce forms of the `ValuePtr` assignment operator in *Case 2* (C&S) and *Case 3* (unified form) *behave the same or different than in Case 1* (direct form).

=== Part II.

* Consider the following definition of the *class `X`*:

[source,c++]
----
class X {
  int i_;                       // non-negative values represent content...
  static const int EMPTY = -1;  // -1 represents no content

  void destroy() { i_ = EMPTY; }

public:
  X(int i) : i_(i) { }
  ~X() { destroy(); }

  X(const X& other) : i_(other.i_)  {
    std::cout << "(CC)";
  }

  X(X&& other) : i_(other.i_) {
    other.destroy();
    std::cout << "(MC)";
  }

  void swap(X& other) { std::swap(i_, other.i_); }
  
#ifdef CASE1
  X& operator=(const X& other) {
      std::cout << "(CA)";
      // ... to be implemented
    }

  X& operator=(X&& other) {
      std::cout << "(MA)";
      // ... to be implemented
  }
#elif defined CASE2
  X& operator=(const X& other) {
    std::cout << "(CA)";
    // ... to be implemented
  }
  
  X& operator=(X&& other) {
    std::cout << "(MA)";
    // ... to be implemented
  }
#elif defined CASE3
  X& operator=(X other) {
    std::cout << "(UA)";
    // ... to be implemented
  }
#endif
};

void swap(X& a, X& b) { a.swap(b); }
----

* Into this class, *implement assignment operators* in:
** the *direct form* if the *preprocessor symbol `CASE1` is defined;
** the *C&S form* if the *preprocessor symbol `CASE2` is defined;
** the *direct form* if the *preprocessor symbol `CASE3` is defined.
* The `X` class implement in the *`X.h`header file*.
* Find out which calls of copy and move special member functions participate in the following operations:
** *copy assignment*,
** *move assignment*,
** *swapping content* with the `std::swap` function,
** *swapping content* with the custom `swap` function related to the `X` class.

== Test Program

Test program code:

[source,c++]
----
#include <iostream>
#include <utility>

#include "X.h"

int main() {
  X x1(1);
  X x2(2);

  std::cout << "copy assignment: ";
  x1 = x2;  
  std::cout << std::endl;
  
  std::cout << "move assignment: ";
  x1 = std::move(x2);
  std::cout << std::endl;

  std::cout << "std::swap: ";
  std::swap(x1, x2);
  std::cout << std::endl;

  std::cout << "custom swap: ";
  swap(x1, x2);
  std::cout << std::endl;
}
----

NOTE: *The form of assignment operators* can be easily *chosen during compilation*, for example, by the following command: `gcc -DCASE1 -o test_case1 test.cpp`.

== Sumbission

* The `X.h` file with the implemnetation of all the forms of assignment operators put into the *root folder of the _practical5_ branch* of your *course project/repository* on *the faculty GitLab instance*.
* Register the submission by *creating the _merge request_*, namely *from the _practical5_ branch into the _master_ branch* inside your project.
* Copy the *output of the test program* for *all the three forms of assigment operators* into the *description text filed of the merge request*.
* Put into this description your *answer to the question from the Part I. of the assignment*. In case of negative answer, *give reasons why the behavior is different*.
* *The deadline for submission* is the *end of the week after the week with your practical class* (according to your time table).

== Testing

* This program is a *part of your project/repository* and will be *automatically compiled and executed after each change* in the source code files.
* A Godbolt online IDE link to the project template with the test program: https://godbolt.org/z/Gqj491ddG.