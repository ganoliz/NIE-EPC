= Practical 5

**Move and emplace semantics, exception safety**

* Přidání podpory přesouvací (move) a emplace sémantiky.
* Korektní ošetření výjimek.

IMPORTANT: Tato úloha navazuje na tu předchozí, t.j. jedná se o vektor s optimalizační technikou _small buffer optimization_.

== Zadání

Implementujte třídní šablonu `vector` ve jmenném prostoru `epc` s následujícím rozhraním.

[source,c++]
----
template <typename T, size_t N>
class vector
{
public:
  vector() noexcept; 

  vector(const vector&);
  vector& operator=(const vector&); 

  vector(vector&&); // <1>
  vector& operator=(vector&&); // <2>

  ~vector();  

  T* data();  
  const T* data() const; 

  T& operator[](size_t); 
  const T& operator[](size_t) const; 

  size_t capacity() const; 
  size_t size() const; 

  void reserve(size_t); 

  void push_back(const T&); 
  void push_back(T&&); // <3>

  template <typename... Ts>
  void emplace_back(Ts&&...); // <4>

  void pop_back();

  void clear(); 

  void swap(vector&);   
};
----
<1> Přesouvací konstruktor
<2> Přesouvací přiřazovací operátor
<3> Vložení prvku pro rhodnotové argumenty
<4> Vložení prvku s emplace sémantikou

== Aplikační programové rozhraní (API)

IMPORTANT: Jsou popsány pouze změny oproti předchozí úloze.

=== Šablonové argumenty

* `T` — hodnotový typ vektoru
** Pokud hodnotový typ poskytuje operace pro přesun obsahu, nesmí tyto operace vyhodit výjimku (_nothrow-move-constructible/assignable_).
** Ostatní požadavky jsou shodné s úlohou č. 3.

=== Speciální členské funkce

* `vector(vector&&)` — *přesouvací konstruktor*
** Cílový vektor bude mít stejný obsah, jaký měl původně zdrojový vektor.
** Zdrojový vektor bude prázdný (jeho velikost bude nulová).

* `operator=(vector&&)` — *přesouvací přiřazovací operátor*
** Cílový vektor bude mít stejný obsah, jaký měl původně zdrojový vektor.
** Zdrojový vektor bude prázdný (jeho velikost bude nulová).

=== Navýšení kapacity

* `reserve(size_t)` — *navýšení kapacity*
** Při realokaci jsou upřednostněny operace pro přesun obsahu, pokud je hodnotový typ implementuje.
** Pokud dojde k vyhození výjimky, zůstane obsah vektoru zachován.

=== Vložení prvků

* `push_back(const T& value)` — *vložení prvku pro lhodnotové argumenty*
** Při inicilizaci nového prvku je obsah zkopírován z objektu, na který je navázán parametr `value`.

* `push_back(T&& value)` — *vložení prvku pro rhodnotové argumenty*
** Při inicilizaci nového prvku je obsah přesunut z objektu, na který je navázán parametr `value`.
** Pokud operace pro přesun obsahu neexistuje, je obsah zkopírován.

* `+template <typename... Ts> emplace_back(Ts&&... vs)+` — *vložení prvku pomocí emplace sémantiky*
** Pro inicializaci prvku je použita technika _perfect forwarding_ aplikovaná na všechny argumenty funkce.

== Ošetřování výjimek

* Veškeré operace musí korektně ošetřovat výjimky (tj. např. nesmí docházet k úniku prostředků).
* V případě odchycení výjimky libovolného typu musí být tato výjimka propagována ven z volání funkce.
* U všech operací platí, že při ukončení operace vyhozením výjímky musí zúčastněné vektory zůstat v platném stavu.

NOTE: Některé operace mohou specifikovat přísnější pravidla pro případy, kdy nastane výjimka.

== Řešení

Řešení zadané úlohy se skládá pouze z implementace třídní šablony `epc::vector`.

=== Implementace

Platí pravidla z první úlohy až na použití větve _practical5_.

== Hodnocení

* Pokud se v rámci hodnocené GitLab _úlohy_ nepodaří testovací program vůbec přeložit kvůli chybám v implementaci, bude udělený počet bodů nulový.
* V případě, že překlad proběhne v pořádu, ale v testovacím programu skončí některé testy neúspěšně, bude uděleno maximálně 5 bodů.
* V případě, že překlad i testy dopadnou v pořádku, může bý udělen až maximální počet bodu, tj. 10.

[IMPORTANT]
====
* Předmětem hodnocení v této úloze bude i efektivita implementace a korektnost s ohledem na problémy, na které bylo upozorněno v rámci cvičení.
* Jedná se například o ošetřování výjimek pouze určitých typů, nekorektní propagace výjimek, zbytečné větvení programu, apod.
====
