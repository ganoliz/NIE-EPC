= Practical 5

**Move and emplace semantics, exception safety**

* Adding support for the move and emplace semantics.
* Correct exception handling.

IMPORTANT: This assignment follows the previous one, i.e., the implementation of a vector with the _small buffer optimization_ techinque.

== Assignment

Implement the class template `vector` in the `epc` namespace with the following interface.

[source,c++]
----
template <typename T, size_t N>
class vector
{
public:
  vector() noexcept; 

  vector(const vector&);
  vector& operator=(const vector&); 

  vector(vector&&); // <1>
  vector& operator=(vector&&); // <2>

  ~vector();  

  T* data();  
  const T* data() const; 

  T& operator[](size_t); 
  const T& operator[](size_t) const; 

  size_t capacity() const; 
  size_t size() const; 

  void reserve(size_t); 

  void push_back(const T&); 
  void push_back(T&&); // <3>

  template <typename... Ts>
  void emplace_back(Ts&&...); // <4>

  void pop_back();

  void clear(); 

  void swap(vector&);   
};
----
<1> Move constructor
<2> Move assignment operator
<3> Element insertion for rvalue arguments
<4> Element insertion with emplace semantics

== Application programming interface (API)

IMPORTANT: Only the changes against the previous assignment are described.

=== Template parameters

* `T` — *value type*
** If the value type provides the moving-content operations, these operations may not throw exceptions (_nothrow-move-constructible/assignable_).
** The other requirement are same as the requirements form the 3rd assignment.

=== Special member functions

* `vector(vector&&)` — *move constructor*
** The target vector will have the same content that, originally, had the source vector.
** The source vector will be empty (its size will be zero).

* `operator=(vector&&)` — *move assignment operator*
** The target vector will have the same content that, originally, had the source vector.
** The source vector will be empty (its size will be zero).

=== Extending capacity

* `reserve(size_t)` — *extends vector capacity*
** In reallocation, the moving-content operations are preferred, if they are provided by the value type.
** If an exception is thrown, the content of the vector is not changed.

=== Element insertion

* `push_back(const T& value)` — *element insertion for lvalue arguments*
** When the new element is initalized, the content is copied into it from the object bound to the parameter `value`.

* `push_back(T&& value)` — *element insertion for rvalue arguments*
** When the new element is initalized, the content is moved into it from the object bound to the parameter `value`.
** If there is no moving-content operation, the content is copied instead.

* `+template <typename... Ts> emplace_back(Ts&&... vs)+` — *element insertion with the emplace semantics*
** New element is initialized with the _perfect forwarding_ technique applied to all the function arguments.

== Ošetřování výjimek

* Veškeré operace musí korektně ošetřovat výjimky (tj. např. nesmí docházet k úniku prostředků).
* V případě odchycení výjimky libovolného typu musí být tato výjimka propagována ven z volání funkce.
* U všech operací platí, že při ukončení operace vyhozením výjímky musí zúčastněné vektory zůstat v platném stavu.

NOTE: Některé operace mohou specifikovat přísnější pravidla pro případy, kdy nastane výjimka.

== Řešení

Řešení zadané úlohy se skládá pouze z implementace třídní šablony `epc::vector`.

=== Implementace

Platí pravidla z první úlohy až na použití větve _practical5_.

== Hodnocení

* Pokud se v rámci hodnocené GitLab _úlohy_ nepodaří testovací program vůbec přeložit kvůli chybám v implementaci, bude udělený počet bodů nulový.
* V případě, že překlad proběhne v pořádu, ale v testovacím programu skončí některé testy neúspěšně, bude uděleno maximálně 5 bodů.
* V případě, že překlad i testy dopadnou v pořádku, může bý udělen až maximální počet bodu, tj. 10.

[IMPORTANT]
====
* Předmětem hodnocení v této úloze bude i efektivita implementace a korektnost s ohledem na problémy, na které bylo upozorněno v rámci cvičení.
* Jedná se například o ošetřování výjimek pouze určitých typů, nekorektní propagace výjimek, zbytečné větvení programu, apod.
====
