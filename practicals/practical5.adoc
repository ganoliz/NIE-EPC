= Practical 5

**Move and emplace semantics, exception safety**

* Adding support for move and emplace semantics.
* Correct exception handling.

IMPORTANT: This assignment follows the previous one, i.e., the implementation of a vector with the _small buffer optimization_ techinque.

== Assignment

Implement the class template `vector` in the `epc` namespace with the following interface.

[source,c++]
----
template <typename T, size_t N>
class vector
{
public:
  vector() noexcept; 

  vector(const vector&);
  vector& operator=(const vector&); 

  vector(vector&&); // <1>
  vector& operator=(vector&&); // <2>

  ~vector();  

  T* data();  
  const T* data() const; 

  T& operator[](size_t); 
  const T& operator[](size_t) const; 

  size_t capacity() const; 
  size_t size() const; 

  void reserve(size_t); 

  void push_back(const T&); 
  void push_back(T&&); // <3>

  template <typename... Ts>
  void emplace_back(Ts&&...); // <4>

  void pop_back();

  void clear(); 

  void swap(vector&);   
};
----
<1> Move constructor
<2> Move assignment operator
<3> Element insertion for rvalue arguments
<4> Element insertion with emplace semantics

== Application programming interface (API)

IMPORTANT: Only the changes against the previous assignment are described.

=== Template parameters

* `T` — *value type*
** If the value type provides the moving-content operations, these operations may not throw exceptions (_nothrow-move-constructible/assignable_).
** The other requirement are same as the requirements form the 3rd assignment.

=== Special member functions

* `vector(vector&&)` — *move constructor*
** The target vector will have the same content that, originally, had the source vector.
** The source vector will be empty (its size will be zero).

* `operator=(vector&&)` — *move assignment operator*
** The target vector will have the same content that, originally, had the source vector.
** The source vector will be empty (its size will be zero).

=== Extending capacity

* `reserve(size_t)` — *extends vector capacity*
** In reallocation, the moving-content operations are preferred, if they are provided by the value type.
** If an exception is thrown, the content of the vector is not changed.

=== Element insertion

* `push_back(const T& value)` — *element insertion for lvalue arguments*
** When the new element is initalized, the content is copied into it from the object bound to the parameter `value`.

* `push_back(T&& value)` — *element insertion for rvalue arguments*
** When the new element is initalized, the content is moved into it from the object bound to the parameter `value`.
** If there is no moving-content operation, the content is copied instead.

* `+template <typename... Ts> emplace_back(Ts&&... vs)+` — *element insertion with the emplace semantics*
** New element is initialized with the _perfect forwarding_ technique applied to all the function arguments.

== Exception handling

* All the operations must correctly handle exceptions (e.g., there may not be any resource leaks).
* If an exception of any type is caught, it needs to be propagated out to the place where the function was called.
* If any operation ends with throwing an exception, the vectors that participate this operations will be in a valid state.

NOTE: Some operations may specify more strict rules for exception handling.

== Solution

A solution of the assigned programming task consists only of the implementation of the `epc::vector` class template.

=== Implementation

The rules from the first practical assignment apply, except using the _practical5_ branch.

== Classification

* If the considered GitLab _job_ will even not be able to build the test program because of an incorrect implementation, the assignment will be classified with 0 points.
* In case that the compilation will succeed but some tests will not pass, the maximum amount of awarded points will be 5.
* In case that all tests will pass, the maximum amount of classification points, i.e., 10, can be awarded.

[IMPORTANT]
====
* The subject of classification of the solution will additionally be the efficiency and corectness in regard with problems that were presented in practical classes.
* These are, for example, handling exception of only some types, incorrect exception propagation, unnecessary code branching, missing inclusion of header files, etc.
====
