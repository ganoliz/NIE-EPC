= Practical 4.2

*Assignment operators*

== Introduction

*Assignment operators* can be implemented in *different forms*. Let us consider the following implementation of the *value pointer `ValuePtr<T>`*:

[source,c++]
----
template <typename T>
class ValuePtr {
  T* ptr_;
  
public:
  ValuePtr() : ptr_(nullptr) { }
  ValuePtr(T* ptr) : ptr_(ptr) { }
  
  ValuePtr(const ValuePtr& other) ... // implemented in Practical 4.1 assignment

  ValuePtr(ValuePtr&& other) ... // implemented in Practical 4.1 assignment

  ~ValuePtr() ... // implemented in Practical 4.1 assignment
  
  void swap(ValuePtr& other) { std::swap(ptr_, other.ptr_); }

  ...  // other member functions
};
----

=== Case 1

*Basic „direct“ implementation of assignment operators* could look like as follows:

[source,c++]
----
ValuePtr& operator=(const ValuePtr& other) {
  if (this != &other) {
    if (ptr_ && other.ptr_) *ptr_ = *other.ptr_;
    else if (other.ptr_) ptr_ = new T(*other.ptr_);
    else if (ptr_) { delete ptr_; ptr_ = nullptr; }
  }
  return *this;
}

ValuePtr& operator=(ValuePtr&& other) {
  if (this != &other) {
    if (ptr_ && other.ptr_) *ptr_ = std::move(*other.ptr_);
    else if (other.ptr_) ptr_ = new T(std::move(*other.ptr_));
    else if (ptr_) { delete ptr_; ptr_ = nullptr_; }
  }
  return *this;
}
----

=== Case 2

Another option is to implement both operators by the *copy-and-swap (C&S) idiom*:

[source,c++]
----
ValuePtr& operator=(const ValuePtr& other) {
  ValuePtr temp(other);
  swap(temp);
  return *this;
}

ValuePtr& operator=(ValuePtr&& other) {
  ValuePtr temp(std::move(other));
  swap(temp);
  return *this;
}
----

=== Case 3 

The third option is to combine both operators into so-called *unified/unifying assignment operator*, where the role of the auxiliary object `temp` is represented by the *operator parameter*:

[source,c++]
----
ValuePtr& operator=(ValuePtr other) {
  swap(other);
  return *this;
}
----

NOTE: The unified assignment operator is technically a *form of the copy assignment operator*.

== Assignment

=== Part I.

* Find out whether the above-introduce forms of the `ValuePtr` assignment operator in *Case 2* (C&S) and *Case 3* (unified form) *behave the same or different than in Case 1* (direct form).

=== Part II.

* Consider the following definition of the *class `X`*:

[source,c++]
----
class X {
  int i_;                       // non-negative values represent content...
  static const int EMPTY = -1;  // -1 represents no content

  void destroy() { i_ = EMPTY; }

public:
  X(int i) : i_(i) { }
  ~X() { destroy(); }

  X(const X& other) : i_(other.i_)  {
    std::cout << "(CC)";
  }

  X(X&& other) : i_(other.i_) {
    other.destroy();
    std::cout << "(MC)";
  }

  void swap(X& other) { std::swap(i_, other.i_); }
  
#ifdef CASE1
  X& operator=(const X& other) {
      std::cout << "(CA)";
      // ... to be implemented
    }

  X& operator=(X&& other) {
      std::cout << "(MA)";
      // ... to be implemented
  }
#elif defined CASE2
  X& operator=(const X& other) {
    std::cout << "(CA)";
    // ... to be implemented
  }
  
  X& operator=(X&& other) {
    std::cout << "(MA)";
    // ... to be implemented
  }
#elif defined CASE3
  X& operator=(X other) {
    std::cout << "(UA)";
    // ... to be implemented
  }
#endif
};

void swap(X& a, X& b) { a.swap(b); }
----

* Into this class, *implement assignment operators* in:
** the *direct form* if the *preprocessor symbol `CASE1` is defined;
** the *C&S form* if the *preprocessor symbol `CASE2` is defined;
** the *direct form* if the *preprocessor symbol `CASE3` is defined.
* The `X` class implement in the *`X.h`header file*.
* Find out which calls of copy and move special member functions participate in the following operations:
** *copy assignment*,
** *move assignment*,
** *swapping content* with the `std::swap` function,
** *swapping content* with the custom `swap` function related to the `X` class.

== Test Program

Podoba testovacího programu:

[source,c++]
----
#include <iostream>
#include <utility>

#include "X.h"

int main() {
  X x1(1);
  X x2(2);

  std::cout << "copy assignment: ";
  x1 = x2;  
  std::cout << std::endl;
  
  std::cout << "move assignment: ";
  x1 = std::move(x2);
  std::cout << std::endl;

  std::cout << "std::swap: ";
  std::swap(x1, x2);
  std::cout << std::endl;

  std::cout << "custom swap: ";
  swap(x1, x2);
  std::cout << std::endl;
}
----

NOTE: *Výběr varianty formy přiřazovacích operátorů* lze snadno *volit při překladu*, například příkazem `gcc -DCASE1 -o test_case1 test.cpp`.

== Sumbission

* Soubor `X.h` s implementací všech forem přiřazovacích operátorů umístěte do *kořenového adresáře větve _practical5_* vašeho *předmětového projektu/repozitáře* na *fakultní instanci GitLab*. 
* Odezvdání realizujte formou *vytvoření požadavku _merge request_*, a to *z větve _practical5_ do větve _master_* v rámci vašeho projektu.
* *Výstup testovacího programu* pro *všechny tři formy přiřazovacích operátorů* zkopírujte do *komentáře k vytvořenému požadavku merge request*.
* Dále do tohoto komentáře uveďte *odpověď na otázku z Části I. zadání*. V případě záporné odpovědi dále uveďte *zdůvodnění proč je chování jiné*.
* *Termín pro odevzdání* je *konec týdne, ve kterém cvičení probíhá* (cvičení, které máte zapsané dle rozvrhu).

== Testing

* Testovací program bude *součástí vašeho projektu/repozitáře* a bude *automaticky přeložen a spouštěn při každé změně* v souborech ze zdrojovým kódem.
* Odkaz na šablonu projektu s testovacím programem do online IDE Godbolt: https://godbolt.org/z/1rsv6bT59.