= Practical 3

**Separation of memory (storage) allocation and deallocation from vector elements initialization and destruction.**

* High efficiency of vectors stems form the allocation of storage for multiple elements at once.
* The allocation itself does not create any elements; these are then in the allocated storage initialized as needed.
* In the same way, element destruction is separated from storage deallocation.

== Examples

[source,c++]
----
{
  epc::vector<std::string> v; // <1>
  v.reserve(3); // <2>  
} // <3>
----

<1> A vector is created by the default constructor.
<2> The storage with the capacity 3 is allocated, i.e., the storage where 3 elements of the value type can be placed (next to each other).
<3> Vector destruction deallocates the storage allocated in the `reserve(3)` call.

IMPORTANT: In the shown code, there is no initialization (and destruction) of any objects of the value type `std::string`.

[source,c++]
----
{
  epc::vector<std::string> v; 
  v.reserve(3); 
  v.push_back(std::string("string literal")); // <1>
  v.pop_back(); // <2>
} 
----
<1> At the beginning of the allocated storage (“0th” position), a new element is initialized. The function argument is used as an initialization argument.
<2> The single vector element is destructed (by destructor).

NOTE: The other steps behave the same as in the previous example.

== Mechanizmy

[IMPORTANT]
====
* Alokace uložiště pro prvky vektoru musí zahrnovat volání alokační funkce `operator new` nebo `::operator new` (pro účely úlohy není mezi těmito možnostmi rozdíl).
* Dealokace každého alokovaného uložiště musí zahrovat volání dealokační funkce `operator delete` nebo `::operator delete`.
* Vytvoření každého prvku vektoru musí zahrnovat použití _placement new_ s příslušným inicializačním výrazem.
* Destrukci každého vytvořeného prvku vektoru musí zahrnovat _pseudo-destructor call_.
====

== Zadání

Implementujte třídní šablonu `vector` ve jmenném prostoru `epc` s následujícím rozhraním a změřte její efektivitu.

[source,c++]
----
template <typename T>
class vector
{
public:
  vector() noexcept; 

  vector(const vector&);
  vector& operator=(const vector&); 

  ~vector();  

  T* data();  
  const T* data() const; 

  T& operator[](size_t); 
  const T& operator[](size_t) const; 

  size_t capacity() const; 
  size_t size() const; 

  void reserve(size_t); 

  void push_back(const T&); 
  void pop_back();

  void clear(); 

  void swap(vector&) noexcept;   
};
----

== Aplikační programové rozhraní (API)

=== Šablonové parametry

* `T` — *hodnotový typ*
** Požadavek pro zarovnání je nejvýše `alignof(std::max_align_t)` (`T` není _over-aligned_).
** Hodnotový typ musí být destruovatelný a destrukce nesmí vyhodit výjimku (_nothrow-destructible_).
** Hodnotový typ musí být konstruovatelný inicializačním výrazem, jehož typ je rovněž `T` (_copy-constructible_).
** Některé členské funkce mohou pro hodnotový typ specifikovat další požadavky.

NOTE: Hodnotový typ nemusí být konstruovatelný bez inicializačního výrazu (_default-constructible_).

=== Speciální členské funkce

* `vector()` — *výchozí konstruktor*
** Nastaví vektor do prázdného stavu, tj. stavu, kdy neobsahuje žádné prvky a jeho kapacita je nulová.
** Nesmí vyhodit výjimku.

* `vector(const vector&)` — *kopírovací konstruktor*
** Cílový vektor bude mít po operaci stejný obsah (obsah vlastněných prvků), jako zdrojový vektor.
** Stav zdrojového vektoru nesmí být změněn.
** Každý prvek cílového vektoru je vytvořen jako kopie příslušného prvku zdrojového vektoru.

* `operator=(const vector&)` — *kopírovací přiřazovací operátor*
** Cílový vektor bude mít po operaci stejný obsah (obsah vlastněných prvků), jako zdrojový vektor.
** Stav zdrojového vektoru nesmí být změněn.
** Obsah prvků cílového vektoru je buď nastaven kopírovacím přířazovacím operátorem nebo kopírováním obsahu při inicializaci.
** Vyžaduje hodnotový typ přiřaditelný výrazem, jehož typ je rovněž `T` (_copy-assignable_).

IMPORTANT: Kopírovací přiřazovací operátor musí fungovat i v případě, že zdrojový a cílový vektor představují stejný objekt (tzv. „self-assignment“).

* `~vector()` — *destruktor* 
** V případě potřeby destruuje existující prvky vektoru a dealokuje alokovanou paměť.

=== Přístup k prvkům

* `data()` — *ukazatel na první prvek*
** Pokud vektor obsahuje nějaké prvky, vrací ukazatel na první z nich. 
** V opačném případě vrátí nulový ukazatel.

NOTE: Funkce existuje ve dvou variantách, tj. jako _(nekonstantní) členská funkce_ a _konstantní členská funkce_.

* `operator[]` — *refernce na požadovaný prvek*
** Pokud vektor obsahuje prvek s indexem `i`, vrátí referenci, která je na něj navázána.
** V opačném případě není chování definováno.

NOTE: Operátor existuje ve dvou variantách, tj. jako _(nekonstantní) členská funkce_ a _konstantní členská funkce_.

=== Informace o vektoru

* `capacity()` — *informace o kapacitě*
** Vrátí informaci o kapacitě vektoru, tj. počtu prvků, které se vejdou do uložiště naposledy alokovaného pomocí alokační funkce `operator new`.

* `size()` — *informace o počtu prvků*
** Vrátí informaci o velikosti vektoru, tj. počtu prvků, které vektor obsahuje/spravuje (tj., které se nacházejí v aktuálně alokovaném uložišti).

=== Navýšení kapacity

* `reserve(size_t capacity)` — *navýšení kapacity*
** Pokud `capacity` je menší nebo rovno aktální kapacitě vektoru, nemá žádný efekt.
** V opačném případě pomocí „realokace“ navýší kapacitu vektoru na `capacity`.
** Realokace zahrnuje následující kroky:
*** Je alokováno nové uložiště s požadovanou kapacitou pomocí alokační funkce `operator new`.
*** Pro každý prvek ve stávajícím uložišti je v novém uložišti vytvořena (inicializována) jeho kopie.
*** Prvky ve stávajícím uložišti jsou destruovány a stávající uložiště je dealokováno.

NOTE: Pro třídní typy jsou kopie prvků vytvářeny pomocí kopírovacího konstruktoru.

=== Vložení a mazání prvků

* `push_back(const T& value)` — *vložení prvku*
** Vytvoří na konci vektoru (adresa `data() + size()`) nový prvek tak, že pro jeho inicializaci použije výraz `value`.
** Pokud při spuštění funkce je velikost vektoru rovna jeho kapacitě, provede nejprve „realokaci“ dle popisu funkce `reserve()`.
** V rámci realokace je stávající kapacita vektoru obecně zdvojnásobena; pouze pokud byla nulová, je nastavena na 1.

* `pop_back()` — *odstranění posledního prvku*
** Pokud vektor není prázdný, destruuje jeho poslední prvek.
** V opačném případě není chování definováno.
** Nemění kapacitu vektoru.

* `clear()` — *odstranění všech prvků*
** Pokud vektor není prázdný, destruuje jeho všechny prvky.
** Nemění kapacitu vektoru.

=== Prohození obsahu

* `swap(vector& other)` — *prohození obsahu*
** Prohodí obsah dvou vektorů, tj. vektor `+*this+` bude po operaci obsahovat stejné prvky, které měl před operací vektor `other`, a opačně.

IMPORTANT: Tato operace nesmí vyhodit výjimku.

== Ošetřování výjimek

V rámci této úlohy není potřeba řešit korektní ošetřování výjimek.

////

* Veškeré implementované operace vektoru musí provádět korektní ošetřování výjimek.

[WARNING]
====
* Pokud v nějaké operaci nastane výjimka, obsah zúčastněných vektorů musí být zachován.
* Toto pravidlo neplatí pouze pro kopírovací přiřazovací operátor.
* Obsahem vektoru se myslí obsah jeho prvků a jejich počet. 
* Stav vektoru se po vyhození výjimky změnit může (např. jeho kapacita), pokud to není v rozporu s výše uvedenými pravidly
====

IMPORTANT: Pokud je nějaká výjímka odchycena v rámci členské funkce vektoru, musí být dále propagována na místo volání této funkce.

////

== Požadavky na implementaci

Platí pravidla z první úlohy.

== Řešení

Řešení zadané úlohy se skládá ze dvou částí:

. implementace třídní šablony `epc::vector`,
. zprávy z měření efektivity této implementace.

=== Implementace

Platí pravidla z první úlohy až na použití větve _practical3_.

=== Měření efektivity

* Změřte efektivitu vaší implementace pomocí programu se zdrojovým kódem v souboru `benchmark.cpp`.
* Měření proveďte přeložením a spuštěním programu na učebnových počítačích, kde jsou veškeré potřebné knihovny dostupné.
* Měření proveďte zvlášť pro program přeložený pomocí překladačů GCC a Clang.
* Překlad lze provést za použití souboru `Makefile` příkazy `make benchmark-gcc a make benchmark-clang`.

==== Závěrečná zpráva z měření 

* Ve zprávě o měření porovnejte naměřené časy s výsledky získanými při první úloze.
* Zahrňte zde rovněž výsledky získané pro `std::vector`.
* Tuto zprávu realizujte formou popisu (pole „Description“) požadavku _merge requrest_ při odevzdání úlohy.
* Ve zprávě uveďte naměřené časy pro jednotlivé implementace vektoru ze sloupce „Time“.
* Do závěrečné zprávy uveďte výsledky měření pro oba překladače.

== Hodnocení

* Pokud se v rámci hodnocené GitLab _úlohy_ nepodaří testovací program vůbec přeložit kvůli chybám v implementaci, bude udělený počet bodů nulový.
* V případě, že překlad proběhne v pořádu, ale v testovacím programu skončí některé testy neúspěšně, bude uděleno maximálně 5 bodů.
* V případě, že překlad i testy dopadnou v pořádku a bude odevzdána zpráva z měření, může bý udělen až maximální počet bodu, tj. 10.
