= Practical 3

**Separation of memory (storage) allocation and deallocation from vector elements initialization and destruction.**

* High efficiency of vectors stems form the allocation of storage for multiple elements at once.
* The allocation itself does not create any elements; these are then in the allocated storage initialized as needed.
* In the same way, element destruction is separated from storage deallocation.

== Examples

[source,c++]
----
{
  epc::vector<std::string> v; // <1>
  v.reserve(3); // <2>  
} // <3>
----

<1> A vector is created by the default constructor.
<2> The storage with the capacity 3 is allocated, i.e., the storage where 3 elements of the value type can be placed (next to each other).
<3> Vector destruction deallocates the storage allocated in the `reserve(3)` call.

IMPORTANT: In the shown code, there is no initialization (and destruction) of any objects of the value type `std::string`.

[source,c++]
----
{
  epc::vector<std::string> v; 
  v.reserve(3); 
  v.push_back(std::string("string literal")); // <1>
  v.pop_back(); // <2>
} 
----
<1> At the beginning of the allocated storage (“0th” position), a new element is initialized. The function argument is used as an initialization argument.
<2> The single vector element is destructed (by destructor).

NOTE: The other steps behave the same as in the previous example.

== Mechanisms

[IMPORTANT]
====
* Storage allocation for vector elements needs to involve call of the `operator new` or `::operator new` allocation function (for the purposes of this programming assignment, there is no difference between these options).
* Deallocation of each allocated storage needs to involve call of the `operator delete` or `::operator delete`.
* Construction of each element needs to involve the use of _placement new_ with a suitable initialization expression.
* Destruction of each element needs to involve the _pseudo-destructor call_.
====

== Assignment

Implement the class template `vector` in the `epc` namespace with the following interface and measure its efficiency:

[source,c++]
----
template <typename T>
class vector
{
public:
  vector() noexcept; 

  vector(const vector&);
  vector& operator=(const vector&); 

  ~vector();  

  T* data();  
  const T* data() const; 

  T& operator[](size_t); 
  const T& operator[](size_t) const; 

  size_t capacity() const; 
  size_t size() const; 

  void reserve(size_t); 

  void push_back(const T&); 
  void pop_back();

  void clear(); 

  void swap(vector&) noexcept;   
};
----

== Application programming interface (API)

=== Template parameters

* `T` — *value type*
** Alignment requirements are `alignof(std::max_align_t)` at most (`T` is not _over-aligned_).
** The value type is destructible and destruction does not throw exceptions (_nothrow-destructible_).
** The value type is constructible by an initialization expression of type `T` (_copy-constructible_).
** Some member functions may specify additional requirements.
 
NOTE: The value type does not need to be constructible without an initialization expression (_default-constructible_).

=== Special member functions

* `vector()` — *default constructor*
** Sets the vector into the empty state, i.e., state, where it does not contain any elements and its capacity is zero.
** Must not throw exceptions.

* `vector(const vector&)` — *copy constructor*
** The target vector have, after the operation, the same content (owned elements) as the source vector.
** The state of the source vector is not changed.
** Each element of the target vector is constructed as a copy of the corresponding element of the source vector.

* `operator=(const vector&)` — *copy assignment operator*
** The target vector have, after the operation, the same content (owned elements) as the source vector.
** The state of the source vector is not changed.
** The content of a target vector element is either assigned by the copy assignment operator or copied during its initialization.
** Requires the value type to be assignable by an expression of type `T` (_copy-assignable_).

IMPORTANT: Copy assignment operator needs to work even in the case where the source and target vectors represent the same object (so-called “self-assignment”).

* `~vector()` — *destructor*
** If needed, destructs all the vector elements and deallocates memory.

=== Elements access

* `data()` — *pointer to the first element*
** If the vector contains some elements, returns a pointer to the first of them.
** Otherwise, returns the null pointer.

NOTE: The function exits in two variants, i.e., as a _(non-constant) member function_ and a _constant member function_.

* `operator[]` — *reference to the desired element*
** If the vector contains the element with the index `i`, returns a reference bound to it.
** Otherwise, the behavior is undefined.

NOTE: The operator exits in two variants, i.e., as a _(non-constant) member function_ and a _constant member function_.

=== Information about vector

* `capacity()` — *information about capacity*
** Returns information about the vector’s capacity, i.e., the number of elments that fits into the storage last time allocated by `operator new`.

* `size()` — *information about element count*
** Returns information about the vector’s size, i.e., the number of elements that the vector contains/manages (i.e., that are in the actually allocated storage).

=== Navýšení kapacity

* `reserve(size_t capacity)` — *navýšení kapacity*
** Pokud `capacity` je menší nebo rovno aktální kapacitě vektoru, nemá žádný efekt.
** V opačném případě pomocí „realokace“ navýší kapacitu vektoru na `capacity`.
** Realokace zahrnuje následující kroky:
*** Je alokováno nové uložiště s požadovanou kapacitou pomocí alokační funkce `operator new`.
*** Pro každý prvek ve stávajícím uložišti je v novém uložišti vytvořena (inicializována) jeho kopie.
*** Prvky ve stávajícím uložišti jsou destruovány a stávající uložiště je dealokováno.

NOTE: Pro třídní typy jsou kopie prvků vytvářeny pomocí kopírovacího konstruktoru.

=== Vložení a mazání prvků

* `push_back(const T& value)` — *vložení prvku*
** Vytvoří na konci vektoru (adresa `data() + size()`) nový prvek tak, že pro jeho inicializaci použije výraz `value`.
** Pokud při spuštění funkce je velikost vektoru rovna jeho kapacitě, provede nejprve „realokaci“ dle popisu funkce `reserve()`.
** V rámci realokace je stávající kapacita vektoru obecně zdvojnásobena; pouze pokud byla nulová, je nastavena na 1.

* `pop_back()` — *odstranění posledního prvku*
** Pokud vektor není prázdný, destruuje jeho poslední prvek.
** V opačném případě není chování definováno.
** Nemění kapacitu vektoru.

* `clear()` — *odstranění všech prvků*
** Pokud vektor není prázdný, destruuje jeho všechny prvky.
** Nemění kapacitu vektoru.

=== Prohození obsahu

* `swap(vector& other)` — *prohození obsahu*
** Prohodí obsah dvou vektorů, tj. vektor `+*this+` bude po operaci obsahovat stejné prvky, které měl před operací vektor `other`, a opačně.

IMPORTANT: Tato operace nesmí vyhodit výjimku.

== Ošetřování výjimek

V rámci této úlohy není potřeba řešit korektní ošetřování výjimek.

////

* Veškeré implementované operace vektoru musí provádět korektní ošetřování výjimek.

[WARNING]
====
* Pokud v nějaké operaci nastane výjimka, obsah zúčastněných vektorů musí být zachován.
* Toto pravidlo neplatí pouze pro kopírovací přiřazovací operátor.
* Obsahem vektoru se myslí obsah jeho prvků a jejich počet. 
* Stav vektoru se po vyhození výjimky změnit může (např. jeho kapacita), pokud to není v rozporu s výše uvedenými pravidly
====

IMPORTANT: Pokud je nějaká výjímka odchycena v rámci členské funkce vektoru, musí být dále propagována na místo volání této funkce.

////

== Požadavky na implementaci

Platí pravidla z první úlohy.

== Řešení

Řešení zadané úlohy se skládá ze dvou částí:

. implementace třídní šablony `epc::vector`,
. zprávy z měření efektivity této implementace.

=== Implementace

Platí pravidla z první úlohy až na použití větve _practical3_.

=== Měření efektivity

* Změřte efektivitu vaší implementace pomocí programu se zdrojovým kódem v souboru `benchmark.cpp`.
* Měření proveďte přeložením a spuštěním programu na učebnových počítačích, kde jsou veškeré potřebné knihovny dostupné.
* Měření proveďte zvlášť pro program přeložený pomocí překladačů GCC a Clang.
* Překlad lze provést za použití souboru `Makefile` příkazy `make benchmark-gcc a make benchmark-clang`.

==== Závěrečná zpráva z měření 

* Ve zprávě o měření porovnejte naměřené časy s výsledky získanými při první úloze.
* Zahrňte zde rovněž výsledky získané pro `std::vector`.
* Tuto zprávu realizujte formou popisu (pole „Description“) požadavku _merge requrest_ při odevzdání úlohy.
* Ve zprávě uveďte naměřené časy pro jednotlivé implementace vektoru ze sloupce „Time“.
* Do závěrečné zprávy uveďte výsledky měření pro oba překladače.

== Hodnocení

* Pokud se v rámci hodnocené GitLab _úlohy_ nepodaří testovací program vůbec přeložit kvůli chybám v implementaci, bude udělený počet bodů nulový.
* V případě, že překlad proběhne v pořádu, ale v testovacím programu skončí některé testy neúspěšně, bude uděleno maximálně 5 bodů.
* V případě, že překlad i testy dopadnou v pořádku a bude odevzdána zpráva z měření, může bý udělen až maximální počet bodu, tj. 10.
