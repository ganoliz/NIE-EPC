= Practical 3

*Included _vs_ dynamically allocated storage*

== Introduction

Consider the `PairInt` class that represents a *pair of integer numbers*. This class is defined in the *`PairInt.h` header file* with the following content:

[source,c++]
----
#ifndef PAIRINT_H
#define PAIRINT_H

class PairInt
{
    int a_, b_;

    static long constructed_;
    static long alive_;
    static long destructed_;

public:
    PairInt(int a, int b) : a_(a), b_(b)
    {
        constructed_++;
        alive_++;
    }

    ~PairInt()
    {
        destructed_++;
        alive_--;
    }

    PairInt(const PairInt&) = delete;
    PairInt(PairInt&&) = delete;
    PairInt& operator=(const PairInt&) = delete;
    PairInt& operator=(PairInt&&) = delete;

    int& a() { return a_; }
    int& b() { return b_; }

    static long constructed() { return constructed_; }
    static long alive()       { return alive_; }
    static long destructed()  { return destructed_; }
};

#endif
----

The *static member variables* are further defined in the *`PairInt.cpp` source file` with the following content:

[source,c++]
----
#include "PairInt.h"

long PairInt::constructed_ = 0;
long PairInt::alive_ = 0;
long PairInt::destructed_ = 0;
----

== Assignment

* *Implement the `PairIntOwner` class* that servers as an *optional owner of an object of type `PairInt`*, while the owned object will be upon reques stored *either in the included or dynamically allocated storage*.
* The `PairIntOwner` class implement *in the `PairIntOwner.h` header file*.


NOTE: To avoid the violation of ODR (_one definition rule_), the member functions needs to be defined either *inside the class definition* or *outside with the `inline` specifier*.

=== Class interface

* `enum Storage { INCLUDED, DYNAMIC }` -- constants used below.

* `PairIntOwner()` -- *default constructor*. *Does not initialize any object* of type `PairInt`.

* `PairIntOwner(Storage s , int a, int b)` -- *converting constructor*. *Creates an object of type `PairInt`* initialized by the `a` and `b` parameters *in storage* that:
** will be *included inside the storage of the owner object* `+*this+` in case when `s` equals `INCLUDED`;
** will be *dynamically allocated* in case when `s` equals `DYNAMIC`.

* `~PairIntOwner()` -- *destructor*. If the owner `+*this+` has initialized/owns an object of type `PairInt` then this is *destructed* (independnelty of in which storage it is).

* `PariInt& value()` -- if the owner `+*this+` owns an object of type `PairInt`, *returns a reference bound to it*. Otherwise causes *undefined behavior*.

NOTE: For the sake of simplicity, all the *special member functions for copying/moving content are disabled*, namely _copy constructor_, _move constructor_, _copy assignment operator_, and _move assignment operator_.

=== Further requirements

* Implement the class in such a way that *when the owned object is accessed* (by using the member function `value()`) *no branching would be necessary*.
* At the same time, try to make the *size of the class objects storage* (size of its binary representation) *as small as possible*, that is, avoid unnecessary member variables.


[IMPORTANT]
====
* For implementation, *do not use any entities from the C++ standard library* (nor any other library).
* The `PairIntOwner.h` file should contain *only a single header file inclusion, namely of `PairInt.h`*.

====

CAUTION: *Do not modify the content of* the `PairInt.h` and `PairInt.cpp` file, nor the file with the *source code of the test program* (see below).

=== Template

For implementation, you can use the *template defined as follows*:.

[source,c++]
----
#ifndef PAIRINTOWNER_H
#define PAIRINTOWNER_H

#include "PairInt.h"

class PairIntOwner
{
    // private members

public:
    enum Storage { INCLUDED, DYNAMIC };

    PairIntOwner()  // default constructor
    { }

    PairIntOwner(Storage s, int a, int b)  // converitng constructor
    { }

    PairIntOwner(const PairIntOwner&) = delete;
    PairIntOwner(PairIntOwner&&) = delete;
    PairIntOwner operator=(const PairIntOwner&) = delete;
    PairIntOwner operator=(PairIntOwner&&) = delete;

    ~PairIntOwner()  // destructor
    { }

    PairInt& value()  // owned objetct accessor
    { }
};

#endif
----

== Odevzdání

* Za *výsledné řešení* se považuje *obsah souboru `PairIntOwner.h`* umístěného v *kořenovém adresáři větve _practical3_* vašeho *předmětového projektu/repozitáře* na *fakultní instanci GitLab*.
* Za *správné řešení* je považována *přeložitelná a funkční implementace* třídy `PairIntOwner` *dle zadání výše*,
* *Termín pro odevzdání* je *konec vašeho cvičení* (cvičení, které máte zapsané dle rozvrhu).

CAUTION: Úlohu je možné odevzat i do *24 hodin po termínu*; v takovém případě ale bude hodnocena *nejvýše 4 body*.

* Odezvdání realizujte formou *vytvoření požadavku _merge request_*, a to *z větve _practical3_ do větve _master_* v rámci vašeho projektu.

== Testování

* Pro účely testování bude použitý *program využívající framework Boost.Test*.
* Tento program bude *součástí vašeho projektu/repozitáře* a bude *automaticky přeložen a spouštěn při každé změně* v souborech ze zdrojovým kódem.
* Odkaz na šablonu projektu s testovacím programem do online IDE Godbolt: https://godbolt.org/z/Gqj491ddG.
* Odkaz na šablonu projektu s testovacím programem do online IDE Wandbox: https://wandbox.org/permlink/r5QZoft6R60qRRjS.