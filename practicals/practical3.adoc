= Practical 3

*Included _vs_ dynamically allocated storage*

== Introduction

Consider the `PairInt` class that represents a *pair of integer numbers*. This class is defined in the *`PairInt.h` header file* with the following content:

[source,c++]
----
#ifndef PAIRINT_H
#define PAIRINT_H

class PairInt
{
    int a_, b_;

    static long constructed_;
    static long alive_;
    static long destructed_;

public:
    PairInt(int a, int b) : a_(a), b_(b)
    {
        constructed_++;
        alive_++;
    }

    ~PairInt()
    {
        destructed_++;
        alive_--;
    }

    PairInt(const PairInt&) = delete;
    PairInt(PairInt&&) = delete;
    PairInt& operator=(const PairInt&) = delete;
    PairInt& operator=(PairInt&&) = delete;

    int& a() { return a_; }
    int& b() { return b_; }

    static long constructed() { return constructed_; }
    static long alive()       { return alive_; }
    static long destructed()  { return destructed_; }
};

#endif
----

The *static member variables* are further defined in the *`PairInt.cpp` source file` with the following content:

[source,c++]
----
#include "PairInt.h"

long PairInt::constructed_ = 0;
long PairInt::alive_ = 0;
long PairInt::destructed_ = 0;
----

== Assignment

* *Implement the `PairIntOwner` class* that servers as an *optional owner of an object of type `PairInt`*, while the owned object will be upon reques stored *either in the included or dynamically allocated storage*.
* The `PairIntOwner` class implement *in the `PairIntOwner.h` header file*.


NOTE: To avoid the violation of ODR (_one definition rule_), the member functions needs to be defined either *inside the class definition* or *outside with the `inline` specifier*.

=== Class interface

* `enum Storage { INCLUDED, DYNAMIC }` -- konstanty využívané níže.

* `PairIntOwner()` -- *výchozí konstruktor*. *Neinicializuje žádný objekt* typu `PairInt`.

* `PairIntOwner(Storage s , int a, int b)` -- *konverzní konstruktor*. *Vytvoří objekt typu `PairInt`* inicializovaný parametry `a` a `b` *v uložišti*, které:
** bude *vložené v rámci uložiště objektu vlastníka* `+*this+` v případě, že `s` má hodnotu `INCLUDED`;
** bude *dynamicky alokované* v případě, že `s` má hodnotu `DYNAMIC`.

* `~PairIntOwner()` -- *destruktor*. V případě, že vlastník `+*this+` inicializoval/vlastní objekt typu `PairInt`, tak ho *zdestruuje* (nezávisle na tom, v jakém uložišti se nachází).

* `PariInt& value()` -- pokud vlastník `+*this+` vlastní objekt typu `PairInt`, *vrátí na něj referneci*. V opačném případě způsobí *nedefinované chování*.

NOTE: Z důvodu jednoduchosti jsou dále *zakázány veškeré speciální členské funkce* týkající se *kopírovací a přesouvací sémantiky*, tj. _kopírovací konstruktor_, _přesouvací konstruktor_, _kopírovací přiřazovací operátror_ a _přesouvací přiřazovací operátor_.

=== Další požadavky

* Implementujte třídu pokud možno tak, aby *při přístupu k vlastněnému objektu* (pomocí členské funkce `value()`) *nebylo potřeba větvení kódu*.
* Zároveň dbejte na to, aby *velikost uložiště třídy* (velikost binární reprezentace) byla *co nejmenší*, tj. aby neobsahovala zbytečné členské proměnné.

[IMPORTANT]
====
* Pro implementaci *nepoužívejte žádné entity ze standardní knihovny C++* (ani z žádné jiné knihovny).
//* Pro implementaci nepoužívejte žádné entity ze standardní knihovny C++ (ani z žádné jiné knihovny) s výjimkou níže jmenovaných.
* Soubor `PairIntOwner.h` by měl obsahovat *vložení jediného hlavičkového souboru, a to `PairInt.h`*.
//* Povolené výjimky (pro implementaci nejsou potřeba):
//** `std::aligned_storage` včetně `std::aligned_storage_t`,
//** `std::constuct_at`,
//** `std::destroy_at`.
====

CAUTION: Nijak *nemodifikujte obsah souborů* `PairInt.h`, `PairInt.cpp`, ani souboru se *zdrojovým kódem testovacího programu* (viz níže).

=== Šablona

Pro implemnetaci můžete využít *šablonu definovanou následovně*:

[source,c++]
----
#ifndef PAIRINTOWNER_H
#define PAIRINTOWNER_H

#include "PairInt.h"

class PairIntOwner
{
    // private members

public:
    enum Storage { INCLUDED, DYNAMIC };

    PairIntOwner()  // default constructor
    { }

    PairIntOwner(Storage s, int a, int b)  // converitng constructor
    { }

    PairIntOwner(const PairIntOwner&) = delete;
    PairIntOwner(PairIntOwner&&) = delete;
    PairIntOwner operator=(const PairIntOwner&) = delete;
    PairIntOwner operator=(PairIntOwner&&) = delete;

    ~PairIntOwner()  // destructor
    { }

    PairInt& value()  // owned objetct accessor
    { }
};

#endif
----

== Odevzdání

* Za *výsledné řešení* se považuje *obsah souboru `PairIntOwner.h`* umístěného v *kořenovém adresáři větve _practical3_* vašeho *předmětového projektu/repozitáře* na *fakultní instanci GitLab*.
* Za *správné řešení* je považována *přeložitelná a funkční implementace* třídy `PairIntOwner` *dle zadání výše*,
* *Termín pro odevzdání* je *konec vašeho cvičení* (cvičení, které máte zapsané dle rozvrhu).

CAUTION: Úlohu je možné odevzat i do *24 hodin po termínu*; v takovém případě ale bude hodnocena *nejvýše 4 body*.

* Odezvdání realizujte formou *vytvoření požadavku _merge request_*, a to *z větve _practical3_ do větve _master_* v rámci vašeho projektu.

== Testování

* Pro účely testování bude použitý *program využívající framework Boost.Test*.
* Tento program bude *součástí vašeho projektu/repozitáře* a bude *automaticky přeložen a spouštěn při každé změně* v souborech ze zdrojovým kódem.
* Odkaz na šablonu projektu s testovacím programem do online IDE Godbolt: https://godbolt.org/z/Gqj491ddG.
* Odkaz na šablonu projektu s testovacím programem do online IDE Wandbox: https://wandbox.org/permlink/r5QZoft6R60qRRjS.