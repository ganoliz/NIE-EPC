= Practical 1

**`vector` and `new[] expression`: Implementation of a simple form of a vector class with the `new[]` expression — how `vector` should not be implemented.**

== Assignment

Implement the class template `vector` in the `epc` namespace with the following interface and measure its efficiency:

[source,c++]
----
template <typename T>
class vector
{
public:
  vector() noexcept; // <1>

  vector(const vector&) = delete; // <2>
  vector& operator=(const vector&) = delete; // <3>

  ~vector(); // <4>

  T* data(); // <5>
  const T* data() const; // <5>

  T& operator[](size_t); // <6>
  const T& operator[](size_t) const; // <6>

  void push_back(const T&); // <7>

  size_t capacity() const; // <8>
  size_t size() const; // <9>
};
----

<1> Default constructor
<2> Copy constructor
<3> Copy assignment operator
<4> Destructor
<5> Pointer to first element
<6> Reference to desired element
<7> Element insertion
<8> Information about capacity
<9> Information about number of elements

NOTE: Details about the interface are in the following section.

== Application programming interface (API)

=== Template parameters

* `T` — *value type*

=== Constructors and destructor

* `vector()` — *default constructor*
** Sets the vector into the empty state, i.e., state, where it does not contain any elements and its capacity is zero.
** Must not throw exceptions.

IMPORTANT: From the above requirements, it implies that the default constructor may not create any objects of the value type nor allocate memory.

* `vector(const vector&)` — *copy constructor*
** Copy constructor is defined as deleted.

* `operator=(const vector&)` — *copy assignment operator*
** Copy assignment operator is defined as deleted.

NOTE: Explicit deletion of the above-mentioned special member functions supresses the generation of the move constructor and the move assignment operator.

* `~vector()` — *destructor*
** If needed, destructs all the vector elements and deallocates memory.

=== Elements access

* `data()` — *pointer to the first element*
** If the vector contains some elements, returns a pointer to the first of them.
** Otherwise, returns the null pointer.

NOTE: The function exits in two variants, i.e., as a _(non-constant) member function_ and a _constant member function_.

* `operator[]` — *reference to the desired element*
** If the vector contains the element with the index `i`, returns a reference bound to it.
** Otherwise, the behavior is undefined.

NOTE: The operator exits in two variants, i.e., as a _(non-constant) member function_ and a _constant member function_.

=== Information about vector

* `capacity()` — *information about capacity*
** Returns information about the vector's capacity, i.e., the size of the array that was last time allocated by the `new[]` expression inside the `push_back` function.

* `size()` — *information about element count*
** Returns information about the vector's size, i.e., the number of elements that were inserted into it by the `push_back` function.

=== Element insertion

* `push_back(const T& value)` — *inserts element*
** Inserts, at the end of the vector, a copy of the object to which the reference `value` is bound.
** If, before the element insertion, the size of the vecotor is equal to its capacity, the capacity must be first (before insertion) extended by peforming so-called “reallocation”. This happes in the following steps:
... A new array of the value type objects is allocated by the `new T[n]` expression, where `n` generally equals the double of the current capacity. Only in case that the current capacity is zero, `n` is set to 1.
... The current vector elements are copied from the original array to the newly allocated array by using the copy assignment operator.
... The original array is destructed/deallocated by the `delete[]` expression.
... The internal vector variables are set such that their state correspond with the new array and the new capacity.

[NOTE]
====
This form of a vector and its reallocation stems from the description of the implementation of dynamic arrays as presented in the BIE-PA2 course. The copy of the corresponding slide form the course lectures which shows the `push_back` member function:

image::images/pa2_l04_p44.png[width=600,align="center"]
====

CAUTION: In the shown implementation, the capacity is extended in a way that does not meet the above-stated requirements for the `epc::vector` class template.

[WARNING]
====
* The shown implementation does not care about exceptions.
* The correct exceptions treatement by the vector implementation will be a part of further assignments; it does not need to be resolved here.
==== 

== Requirements for implementation

* For implementation, use a single header file `vector.h` only.
* For implementation, use the {cpp}11 standard or newer.

[WARNING]
====
* The choice of the standard needs to enable the compilation of the test and benchmark programs.
* The test program is built automatically in the GitLab system by using GCC version 11 in the Alpine Linux 3.16 environment.
* The benchmark program needs to be built on the classroom computers in the Linux environment; the available versions of the compilers may be found by the `g{plus}{plus} --version` and `clang{plus}{plus} --version` commands.
* For the support of particular features of the standards by different {cpp} implementations, see https://en.cppreference.com/w/cpp/compiler_support or the documentation for particular implementations.
====

== Solution

* A solution of the assigned programming task consists of two parts:
.. the implementation of the `epc::vector` class template,
.. the report from the measurement of its efficiency.

=== Implementation

* Za výsledné řešení se považuje obsah souboru `vector.h` umístěného v kořenovém adresáři větve _practical1_ vašeho předmětového projektu na fakultní instanci GitLab.

NOTE: Větev _practical1_ vašeho projektového adresáře obsahuje předpřipravenou šablonu hlavičkového souboru `vector.h`.

* Za správné řešení je považována přeložitelná a funkční implementace třídní šablony `epc::vector` dle zadání výše.
* Funkčnost řešení je automaticky testována pomocí testovacího programu.
* Volbu standardu pro testování lze provést aktualizací souboru `config.mk`.

CAUTION: Ve větvi _practical1_ vašeho předmětového projektu neměňte obsah žádného z existujících souborů s výjimkou souborů `vector.h` a `config.mk`.

=== Měření efektivity

* Změřte efektivitu vaší implementace pomocí programu se zdrojovým kódem v souboru `benchmark.cpp`.
* Program porovnává na vybraných operacích efektivitu vaší implementace s třemi různými existujícími implementacemi vektorové třídy:
.. `std::vector` ze standardní knihovy {cpp},
.. `boost::container::small_vector` z knihovny Boost.Container.
.. `llvm::SmallVector` z knihovny LLVM ADT.
* Měření proveďte přeložením a spuštěním programu na učebnových počítačích, kde jsou veškeré potřebné knihovny dostupné.
* Měření proveďte zvlášť pro program přeložený pomocí překladačů GCC a Clang.
* Překlad lze provést za použití souboru `Makefile` příkazy `make benchmark-gcc a make benchmark-clang`.

==== Závěrečná zpráva z měření 

* Z výsledků měření efektivity vytvořte jednoduchou závěrečnou zprávu.
* Tuto zprávu realizujte formou popisu (pole „Description“) požadavku _merge requrest_ při odevzdání úlohy.
* Ve zprávě uveďte naměřené časy pro jednotlivé implementace vektoru ze sloupce „Time“.
* Do závěrečné zprávy uveďte výsledky měření pro oba překladače.

== Hodnocení

* Pokud se v rámci hodnocené GitLab _úlohy_ nepodaří testovací program vůbec přeložit kvůli chybám v implementaci, bude udělený počet bodů nulový.
* V případě, že překlad proběhne v pořádu, ale v testovacím programu skončí některé testy neúspěšně, bude uděleno maximálně 5 bodů.

[IMPORTANT]
====
* Udělování bodů v takovém případě nelze kvantifikovat pouze na základě výsledků testů.
* Místo toho bude provedena revize kódu a body budou uděleny s ohledem na závažnost chyb v implementaci.
====

* V případě, že překlad i testy dopadnou v pořádku a bude odevzdána zpráva z měření, může bý udělen až maximální počet bodu, tj. 10.

[IMPORTANT] 
====
* I v takovém případě se ale může stát, že udělelný počet bodu bude nižší.
* Obecně nelze korektnost implementace vyhodnotit pouze na základě testů.
* Pokud při revizi kódu budou zjištěny chyby, bude počet bodů snížen dle jejich závažnosti.
====
