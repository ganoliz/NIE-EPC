= Practical 6

*Copy elision*

== Introduction

=== Case 1

Consider the following definition of the *function template `std::make_unique`*:

[source,c++]
----
// in std namespace: 

template <typename T, typename... Ts>
unique_ptr<T> make_unique(Ts&&... params)
{
  return unique_ptr<T>(new T(forward<Ts>(params)...));
}
----

The question is whetehr its use brings some *runtime overhead*. Example:

[source,c++]
----
std::unique_ptr<int> upi { new int(1) };  // option (1)
auto upi = std::make_unique<int>(1);      // option (2)
----

In case (1), the object `upi` is initialized *directly by the converting constructor*. On the contrary, in case (2), the situation is much more complicated:

. First, a *temporary object* is initialized by the converting constructor.
. Then, the *return value* is initialized from that temporary object by the move constructor.
. Finally, the *object `upi`* is initialized from the return value by the move constructor.

The *copy elision* optimization techinque allows here to *elide/eliminate thost two move constructor calls* and effectively *directly initialize the `upi` object* by the initializataion expression `new T(std::forward<Ts>(params)...)`. 

CAUTION: This optimization is enabled even in cases where move (or copy) constructors *have observable side effects*. In such cases it effectively *modifies observable behavior of the program*.

Generally, the copy elision optimization technique has multiple forms. The form applied above is called *return value optimization (RVO)*. RVO is:

- *optional until {cpp}17*,
- *mandatory {cpp}17*.

=== Case 2

How the situation changes if we *rewrite* the function template `std::make_unique` *as follows*?

[source,c++]
----
template <typename T, typename... Ts>
unique_ptr<T> make_unique(Ts&&... params)
{
  unique_ptr<T> temp{new T(forward<Ts>(params)...)};
  return temp;
}
----

*Without application of copy elision*, the situation for case (2) is similar:

. First, the *temporary variable `temp`* is initialized by the converting constructor.
. The, the *return value* is initialized from `temp` by the _move constructor_.
. Finally, the *`upi` object* is initialized from the return value by the move constructor.

CAUTION: How is it possible that the return value is initialized by the *move constructor* when the value cateogry of the initialization expression `temp` is *lvalue*?

The copy elision optimization technique can be applied in this case as well. Since the initialization expression of the return value is a named variable, this form of copy elision is called *named return value optimization (NRVO)*. NRVO is:

- *optional until C++17*,
- *optional since C++17*.

=== Case 3

There is a *third option* how to implement the function template`make_unique`:

[source,c++]
----
template <typename T, typename... Ts>
unique_ptr<T> make_unique(Ts&&... params)
{
  unique_ptr<T> temp{new T(forward<Ts>(params)...)};
  return std::move(temp);  // "make rvalue" from temp
}
----

Without the application of copy elision is this form *effectively equivalent with the previous form* (without `std::move`). But what if copy elision is applied? Then, the use of `std::move` in fact *hinders* this optimization.

CAUTION: The use of `std::move` for initialization of the return value is here *wrong from the perspective of efficiency*.

=== Copy elision control

- The *GCC a Clang* implementations do apply copy elision even when *optimizations are disable* by the `-O0` compiler command line argument. 
- To disable copy elision, one needs to use a *special command line argument* `-fno-elide-constructors`.

WARNING: This argument disables copy elision only *if its application is not mandatory*. This happens *in some cases since {cpp}17*.

== Assignment

Uvažujte následující definici *třídy `X`* umístěnou v *hlavičkovém souboru* `X.h`:

[source,c++]
----
struct in_place_t { };

struct X
{
  template <typename... Ts>
  X(in_place_t, Ts&&...) { }  // converting-forwarding constructor
  
  X(const X&) { std::cout << "(CC)"; }  // copy constructor
  X(X&&) { std::cout << "(MC)"; }       // move constructor
};
----

Implementujte *tři varianty volné funkční šablony `make_X`*, která:

- na vstupu vezme *libovolný počet argumentů libovolných typů*,
- *vrátí* objekt typu `X` inicializovaný *konverzním konstruktorem*,
- kterému jsou *předány veškeré argumenty pomocí techniky perfect forwarding*.

NOTE: Podobným způsobem pracuje např. funkce `std::make_optional` pro *vytváření objektů typu `std::optional`*.

Tyto tři varianty budou *odpovídat případům Case 1, Case 2 a Case 3* pro šablonu `make_unique` ukázanou výše. Konkrétně:

- v prvním případě bude vrácen *dočasný objekt* typu `X`.
- ve druhém případě bude vrácena *lokální proměnná* typu `X`,
- ve třetím případě bude vrácena *lokální proměnná* typu `X` *„obalená“ voláním funkce `std::move`*.

Všechny 3 varianty *doplňte do hlavičkového souboru `X.h`*, kde jejich „volba“ bude *umožněna definicí symbolů preprocesoru* `CASE1`, `CASE2` a `CASE3`:

[source,c++]
----
#ifdef CASE1

template <typename... Ts>
X make_X(Ts&&... params) {
  // ... to be implemented
}

#elif defined CASE2

template <typename... Ts>
X make_X(Ts&&... params) {
  // ... to be implemented
}

#elif defined CASE3

template <typename... Ts>
X make_X(Ts&&... params) {
  // ... to be implemented
}

#endif
----

=== Testovací program

Na následujícím testoavcím programu vyzkoušejte, jak se budou *jednotlivé varianty* chovat při *zapnuté a vypnuté optimalizaci copy elision* při *inicializaci objekty typu X*:

[source,c++]
----
#include <iostream>
#include "X.h"

int main()
{
  int i = 1;
  auto x = make_X(i, true);
  std::cout << std::endl;
}
----

IMPORTANT: Z důvodu nemožnosti deaktivovat RVO v {cpp}17 *použijte pro testování standard {cpp}11 nebo {cpp}14*. U implementací *GCC a Clang* k tomu slouží *přepínače* `pass:[-std=c++14]` a `pass:[-std=c++17]`.

Dále *zdůvodněte*, proč se v případě Case 2 *použije pro inicializaci návratové hodnoty přesouvací a nikoliv kopírovací konstruktor*. Zdůvodnění hledejte v *aktuálním draftu standardu {cpp}*, konkrétně v části *[class.copy.elison]*; odkaz: http://eel.is/c++draft/class.copy.elision.

== Odevzdání

* Implementaci *všech tří verzí funkční šablony `make_X`* proveďte v rámci *hlavičkového souboru `X.h`* umístěného v *kořenovém adresáři větve _practical6_* vašeho *předmětového projektu/repozitáře* na *fakultní instanci GitLab*. 
* Odezvdání realizujte formou *vytvoření požadavku _merge request_*, a to *z větve _practical6_ do větve _master_* v rámci vašeho projektu.
* *Výstup testovacího programu* pro *všechny tři varianty funkční šablony `make_X`* pro *vypnutou i zapnutou aplikaci copy elision* zkopírujte do *popisu (description) k vytvořenému požadavku merge request*.
* Dále do tohoto popisu uveďte *zdůvodnění* použití *přesouvacího konstruktoru* v případě Case 2.
* *Termín pro odevzdání* je *konec týdne, ve kterém cvičení probíhá* (cvičení, které máte zapsané dle rozvrhu).

== Testování

* Testovací program bude *součástí vašeho projektu/repozitáře* a bude *automaticky přeložen a spouštěn při každé změně* v souborech ze zdrojovým kódem.
* Odkaz na šablonu projektu s testovacím programem do online IDE Godbolt: https://godbolt.org/z/qexMjxnr4.