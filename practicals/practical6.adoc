= Practical 6

*Copy elision*

== Introduction

=== Case 1

Consider the following definition of the *function template `std::make_unique`*:

[source,c++]
----
// in std namespace: 

template <typename T, typename... Ts>
unique_ptr<T> make_unique(Ts&&... params)
{
  return unique_ptr<T>(new T(forward<Ts>(params)...));
}
----

The question is whetehr its use brings some *runtime overhead*. Example:

[source,c++]
----
std::unique_ptr<int> upi { new int(1) };  // option (1)
auto upi = std::make_unique<int>(1);      // option (2)
----

In case (1), the object `upi` is initialized *directly by the converting constructor*. On the contrary, in case (2), the situation is much more complicated:

. First, a *temporary object* is initialized by the converting constructor.
. Then, the *return value* is initialized from that temporary object by the move constructor.
. Finally, the *object `upi`* is initialized from the return value by the move constructor.

The *copy elision* optimization techinque allows here to *elide/eliminate thost two move constructor calls* and effectively *directly initialize the `upi` object* by the initializataion expression `new T(std::forward<Ts>(params)...)`. 

CAUTION: This optimization is enabled even in cases where move (or copy) constructors *have observable side effects*. In such cases it effectively *modifies observable behavior of the program*.

Generally, the copy elision optimization technique has multiple forms. The form applied above is called *return value optimization (RVO)*. RVO is:

- *optional until {cpp}17*,
- *mandatory {cpp}17*.

=== Case 2

How the situation changes if we *rewrite* the function template `std::make_unique` *as follows*?

[source,c++]
----
template <typename T, typename... Ts>
unique_ptr<T> make_unique(Ts&&... params)
{
  unique_ptr<T> temp{new T(forward<Ts>(params)...)};
  return temp;
}
----

*Without application of copy elision*, the situation for case (2) is similar:

. First, the *temporary variable `temp`* is initialized by the converting constructor.
. The, the *return value* is initialized from `temp` by the _move constructor_.
. Finally, the *`upi` object* is initialized from the return value by the move constructor.

CAUTION: How is it possible that the return value is initialized by the *move constructor* when the value cateogry of the initialization expression `temp` is *lvalue*?

The copy elision optimization technique can be applied in this case as well. Since the initialization expression of the return value is a named variable, this form of copy elision is called *named return value optimization (NRVO)*. NRVO is:

- *optional until C++17*,
- *optional since C++17*.

=== Case 3

There is a *third option* how to implement the function template`make_unique`:

[source,c++]
----
template <typename T, typename... Ts>
unique_ptr<T> make_unique(Ts&&... params)
{
  unique_ptr<T> temp{new T(forward<Ts>(params)...)};
  return std::move(temp);  // "make rvalue" from temp
}
----

Without the application of copy elision is this form *effectively equivalent with the previous form* (without `std::move`). But what if copy elision is applied? Then, the use of `std::move` in fact *hinders* this optimization.

CAUTION: The use of `std::move` for initialization of the return value is here *wrong from the perspective of efficiency*.

=== Copy elision control

- The *GCC a Clang* implementations do apply copy elision even when *optimizations are disable* by the `-O0` compiler command line argument. 
- To disable copy elision, one needs to use a *special command line argument* `-fno-elide-constructors`.

WARNING: This argument disables copy elision only *if its application is not mandatory*. This happens *in some cases since {cpp}17*.

== Assignment

Consider the following definition of the *class `X`* stored in the `X.h` header file:

[source,c++]
----
struct in_place_t { };

struct X
{
  template <typename... Ts>
  X(in_place_t, Ts&&...) { }  // converting-forwarding constructor
  
  X(const X&) { std::cout << "(CC)"; }  // copy constructor
  X(X&&) { std::cout << "(MC)"; }       // move constructor
};
----

Implement *three variants of the free function template `make_X`* that:

- takes an *arbitrary number of arguments of any types*,
- *returns* an object of type `X` initialized by the *converting constructor*
- to which *all the arguments are perfectly forwarded*.

NOTE: Similarly, the `std::make_optional` works for *making objects of type `std::optional`*.

These three variants will *correspond with the Case 1, Case 2, and Case 3 cases* for `make_unique` template shown above. Namely:

- in the first case, a *temporary object* of type `X` will be returned;
- in the second case, a *local variable* of type `X` will be returned;
- in the third case, a *local variable* of type `X` *wrapped by the `std::move` call* will be returned.

All these 3 variants *put into the `X.h` header file`, where their “choice” will be *enabled by definition of the preprocessor symbols* `CASE1`, `CASE2` and `CASE3`:

[source,c++]
----
#ifdef CASE1

template <typename... Ts>
X make_X(Ts&&... params) {
  // ... to be implemented
}

#elif defined CASE2

template <typename... Ts>
X make_X(Ts&&... params) {
  // ... to be implemented
}

#elif defined CASE3

template <typename... Ts>
X make_X(Ts&&... params) {
  // ... to be implemented
}

#endif
----

=== Test program

With the following test program, show how *particular variatns* will behave with *enabled and disabled copy elision optimization technique* when an *object of type `X`* is initialized.

[source,c++]
----
#include <iostream>
#include "X.h"

int main()
{
  int i = 1;
  auto x = make_X(i, true);
  std::cout << std::endl;
}
----

IMPORTANT: For the reason of the inability to disable RVO in {cpp}17, *use for testing either {cpp}11 or {cpp}14*. With the *GCC and Clang* implementations, this can be accomplished by the `pass:[-std=c++14]` and `pass:[-std=c++17]` command line arguments.

Then, *explain* why in the Case 2 *the move constructor instead of the copy constructor is used for initialization of the return value*. Look for the explanation in the *actual {cpp} draft standard*, namely in its part *[class.copy.elison]*; link: http://eel.is/c++draft/class.copy.elision.

== Submission

* Your implementation of *all three variants of the function template `make_X`* put into the *`X.h` header file* located in the *root folder of the _practical6_ branch* of your *course project/repository* on *the faculty GitLab instance*.
* Register the submission by *creating the _merge request_*, namely *from the _practical6_ branch into the _master_ branch* inside your project.
* Copy the *output of the test program* for *all the three variants of `make_X`* and both *disabled and enabled application of copy elision* into the *description text filed of the merge request*.
* Put into this desription the *explanation* for the *use of the move constructor* in Case 2.
* *The deadline for submission* is the *end of the week after the week with your practical class* (according to your time table).

== Testing

* This program is a *part of your project/repository* and will be *automatically compiled and executed after each change* in the source code files.
* A Godbolt online IDE link to the project template with the test program: https://godbolt.org/z/qexMjxnr4.